int GetCurrentDeviation() {
    return 10; // Devolver el valor por defecto
}

//+------------------------------------------------------------------+
//| Funci√≥n para encontrar la secuencia que corresponde a un ticket  |
//+------------------------------------------------------------------+
int EncontrarSecuenciaPorTicket(ulong ticket)
{
    if(ticket == 0) return -1;
    
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tama√±o del array
    {
        if(secuencias[i].activa)
        {
            // Buscar primero en tickets registrados espec√≠ficos
            if(secuencias[i].ticketEntrada1 == ticket || secuencias[i].ticketEntrada2 == ticket)
                return i;
                
            // Buscar en array de √∫ltimas √≥rdenes
            for(int j = 0; j < secuencias[i].numOrdenes; j++)
            {
                if(secuencias[i].ultimasOrdenes[j] == ticket)
                    return i;
            }
        }
    }
    
    return -1; // No encontrado
}

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
#property copyright "Your Name"
#property link      "https://www.yourwebsite.com"
#property version   "1.00"
#property strict

// Incluir archivos necesarios
#include <Trade\Trade.mqh>

// Prefijo para identificar objetos del EA
string EA_OBJ_PREFIX = "EA_SECUENCIAS_";

// Identificadores de objetos
string panelPrincipalID = "PanelPrincipal";
string editLotajeID = "EditLotaje";
string botonCompraID = "BotonCompra";
string botonVentaID = "BotonVenta";
string editTP1ID = "EditTP1";
string editPipsEntrada2ID = "EditPipsEntrada2";
string editTP2ID = "EditTP2";
string editNumEntradaID = "EditNumEntrada"; 
string editMinimaGID = "EditMinimaG"; // Campo para Minima G.
string editNumCerrarID = "EditNumCerrar"; // NUEVO campo para # Cerrar

// Variables globales
double LotajeInicial = 0.01;
int TP1Puntos = 100;
int PipsEntrada2 = 20;
int TP2Puntos = 100;
int NumEntrada = 0; // CAMBIADO: Inicializado en 0 para permitir campo vac√≠o
double MinimaG = 0.0; // Valor para el campo Minima G.
int NumCerrar = 0; // N√∫mero de entrada en el que se cerrar√° toda la secuencia
bool interfazCreada = false;

// Variable para controlar la verificaci√≥n de √≥rdenes pendientes
datetime ultimaVerificacionPendientes = 0;

// Estructura para almacenar datos de secuencia
struct SecuenciaInfo {
    int id;                  // Identificador √∫nico de secuencia
    bool activa;             // Si la secuencia est√° activa
    double precioEntrada1;   // Precio de la entrada 1
    double precioEntrada2;   // Precio de la entrada 2
    double tp1Precio;        // Precio TP de entrada 1
    double tp2Precio;        // Precio TP de entrada 2
    int secuenciaActual;     // N√∫mero actual de entrada en la secuencia
    datetime tiempoInicio;   // Tiempo de inicio
    ulong ultimasOrdenes[10]; // Tickets de las √∫ltimas √≥rdenes en la secuencia
    int numOrdenes;          // Contador de √≥rdenes en ultimasOrdenes
    datetime ultimaVerificacionTP; // √öltimo tiempo de verificaci√≥n de TP
    bool tpAlcanzado;        // Indica si se detect√≥ TP
    bool cerradaCompletamente; // Indica si la secuencia se cerr√≥ completamente
    int intentosCierre;      // Contador de intentos de cierre
    datetime ultimoCierreIntentado; // √öltimo momento en que se intent√≥ cerrar
    bool esModoCompra;       // Indica si es una secuencia iniciada con COMPRA (true) o VENTA (false)
    ulong ticketEntrada1;    // Ticket de la entrada 1
    ulong ticketEntrada2;    // Ticket de la entrada 2
    bool entradaPendienteActiva; // Indica si hay una entrada pendiente activa
    datetime ultimaRecreacionPendiente; // Tiempo de la √∫ltima recreaci√≥n de la orden pendiente
    bool cerradaManualmente; // Indica si la entrada pendiente fue cerrada manualmente
    datetime ultimaVerificacionPendientes; // √öltimo tiempo que se verific√≥ si hay pendientes
    bool sinOrdenesPendientesDetectado; // Flag para saber si ya se detect√≥ que no hay pendientes
    bool tpReubicado;  // Nuevo campo para controlar si ya se reubic√≥ el TP
    int ultimasPosicionesConsideradas; // N√∫mero de posiciones en el √∫ltimo c√°lculo de TP
};

// Array para almacenar m√∫ltiples secuencias sin l√≠mite estricto
SecuenciaInfo secuencias[20]; // Ampliado a 20 secuencias para dar m√°s holgura
int totalSecuencias = 0;
int proximoIDSecuencia = 1;

// Instancia de CTrade
CTrade trade;

// Declaraciones previas de funciones para evitar errores de compilaci√≥n
void CerrarSecuencia(int indice);
void CerrarTodasLasOrdenesDeSecuencia(int indice, bool cierreRapido = false);
void RecuperarOrdenesPendientes();
void CerrarTodasLasSecuencias();
void IniciarSecuencia(bool esCompra);
void IniciarSecuenciaCompra();
void IniciarSecuenciaVenta();
void LimpiarSecuenciasFantasma();
void VerificarOrdenesPendientes();
void VerificarCierrePorFaltaDePendientes();
void VerificarNuevasActivaciones(int indice);
void VerificarCierrePorNumeroEntrada(int indiceSecuencia);
bool RecrearOrdenEntrada2(int indice);
void GuardarEstadoSecuencias();
void GuardarEstadoSecuenciasConID();
void ResetearSecuencia(int indice);
void RestaurarEstadoSecuencias();
void CrearInterfaz();
void CrearPanelPrincipal(int x, int y, int ancho, int alto);
void CrearBoton(string id, string texto, int x, int y, int ancho, int alto, color bgColor);
void CrearCampoEdicionEstilizado(string id, string label, int x, int y, int ancho, int alto, string valor);
void ReubicarTPsParaGarantiaMinimaG(int indiceSecuencia);
void DiagnosticarSecuencia(int indiceSecuencia);
void LimpiarOrdenesHuerfanas();
void GuardarValores();
void RegistrarOrden(int indice, ulong ticket, string comentario="");
void ProgramarSiguienteEntrada(int indice);
int EncontrarSecuenciaPorTicket(ulong ticket);
void RecalcularTotalSecuencias();
void LimpiarSecuenciasProblematicas();
void ActualizarInformacionSecuencias();
bool TieneOrdenesPendientes(int indice, bool &tieneMultiples);
void EliminarOrdenesPendientesDuplicadas(int indice);
double CalcularComisionPepperstone(double volumen);
double CalcularPLTotalConTP(int indiceSecuencia, double precioTP);
bool VerificarExistenciaOrdenPendiente(ulong ticket);
void ResetearTodasLasSecuencias();
void RestaurarValores();

//+------------------------------------------------------------------+
//| Funci√≥n para capturar eventos de trading (√≥rdenes, posiciones)   |
//+------------------------------------------------------------------+
void OnTradeTransaction(const MqlTradeTransaction& trans,
                       const MqlTradeRequest& request,
                       const MqlTradeResult& result)
{
    // Solo nos interesa detectar eliminaciones de √≥rdenes pendientes
    if(trans.type == TRADE_TRANSACTION_ORDER_DELETE)
    {
        ulong ticketEliminado = trans.order;
        
        // Encontrar a qu√© secuencia pertenece esta orden
        int indiceSecuencia = EncontrarSecuenciaPorTicket(ticketEliminado);
        if(indiceSecuencia >= 0)
        {
            // Verificar si es la orden ENTRADA #2
            if(secuencias[indiceSecuencia].ticketEntrada2 == ticketEliminado)
            {
                // Si la raz√≥n de eliminaci√≥n NO es cambio de timeframe o activaci√≥n,
                // asumimos que fue eliminaci√≥n manual
                if(trans.order_state == ORDER_STATE_CANCELED)
                {
                    Print("üñêÔ∏è Detectada eliminaci√≥n manual de orden pendiente #", ticketEliminado, 
                          " para secuencia #", secuencias[indiceSecuencia].id);
                    
                    secuencias[indiceSecuencia].cerradaManualmente = true;
                    secuencias[indiceSecuencia].entradaPendienteActiva = false;
                    
                    // Guardar este estado para persistencia
                    GuardarEstadoSecuencias();
                }
            }
        }
    }
}
//+------------------------------------------------------------------+
//| ChartEvent function                                              |
//+------------------------------------------------------------------+
void OnChartEvent(const int id, const long &lparam, const double &dparam, const string &sparam)
{
    // Asegurarse de que la interfaz siempre est√° presente
    if(!interfazCreada) {
        CrearInterfaz();
        interfazCreada = true;
    }
    
    // Si se detecta un cambio en alg√∫n control de edici√≥n
    if(id == CHARTEVENT_OBJECT_ENDEDIT) 
    {
        // Capturar el valor actualizado cada vez que el usuario edita un campo
        if(sparam == EA_OBJ_PREFIX + editLotajeID) 
        {
            string texto = ObjectGetString(0, sparam, OBJPROP_TEXT);
            LotajeInicial = StringToDouble(texto);
            // Guardar inmediatamente
            GlobalVariableSet("EA_LOTAJE_" + Symbol(), LotajeInicial);
            Print("Lotaje actualizado a: ", LotajeInicial);
        }
        else if(sparam == EA_OBJ_PREFIX + editTP1ID) 
        {
            string texto = ObjectGetString(0, sparam, OBJPROP_TEXT);
            TP1Puntos = (int)StringToInteger(texto);
            GlobalVariableSet("EA_TP1_" + Symbol(), TP1Puntos);
            Print("TP1 actualizado a: ", TP1Puntos);
        }
        else if(sparam == EA_OBJ_PREFIX + editPipsEntrada2ID) 
        {
            string texto = ObjectGetString(0, sparam, OBJPROP_TEXT);
            PipsEntrada2 = (int)StringToInteger(texto);
            GlobalVariableSet("EA_PIPS_E2_" + Symbol(), PipsEntrada2);
            Print("Pips Entrada2 actualizado a: ", PipsEntrada2);
        }
        else if(sparam == EA_OBJ_PREFIX + editTP2ID) 
        {
            string texto = ObjectGetString(0, sparam, OBJPROP_TEXT);
            TP2Puntos = (int)StringToInteger(texto);
            GlobalVariableSet("EA_TP2_" + Symbol(), TP2Puntos);
            Print("TP2 actualizado a: ", TP2Puntos);
        }
        else if(sparam == EA_OBJ_PREFIX + editNumEntradaID) 
        {
            string texto = ObjectGetString(0, sparam, OBJPROP_TEXT);
            // Permitir campo vac√≠o o "0"
            if(texto == "" || texto == "0")
            {
                NumEntrada = 0;
            }
            else
            {
                NumEntrada = (int)StringToInteger(texto);
            }
            GlobalVariableSet("EA_NUM_ENTRADA_" + Symbol(), NumEntrada);
            Print("# Reubicar actualizado a: ", NumEntrada);
        }
        else if(sparam == EA_OBJ_PREFIX + editMinimaGID) 
        {
            string texto = ObjectGetString(0, sparam, OBJPROP_TEXT);
            MinimaG = StringToDouble(texto);
            GlobalVariableSet("EA_MINIMA_G_" + Symbol(), MinimaG);
            Print("Minima G. actualizada a: ", MinimaG);
        }
        else if(sparam == EA_OBJ_PREFIX + editNumCerrarID) 
        {
            string texto = ObjectGetString(0, sparam, OBJPROP_TEXT);
            // Permitir campo vac√≠o o "0"
            if(texto == "" || texto == "0")
            {
                NumCerrar = 0;
            }
            else
            {
                NumCerrar = (int)StringToInteger(texto);
            }
            GlobalVariableSet("EA_NUM_CERRAR_" + Symbol(), NumCerrar);
            Print("# Cerrar actualizado a: ", NumCerrar);
        }
    }
    
    // Si se detecta un cambio de timeframe
    if(id == CHARTEVENT_CHART_CHANGE)
    {
        Print("Cambio de chart detectado - Asegurando persistencia de √≥rdenes");
        
        // Guardar el estado actual de las secuencias antes del cambio, incluyendo ID
        GuardarEstadoSecuenciasConID();
        
        // Guardar los valores actuales de los controles antes de recrear la interfaz
        if(ObjectFind(0, EA_OBJ_PREFIX + editLotajeID) >= 0)
            LotajeInicial = StringToDouble(ObjectGetString(0, EA_OBJ_PREFIX + editLotajeID, OBJPROP_TEXT));
            
        if(ObjectFind(0, EA_OBJ_PREFIX + editTP1ID) >= 0)
            TP1Puntos = (int)StringToInteger(ObjectGetString(0, EA_OBJ_PREFIX + editTP1ID, OBJPROP_TEXT));
            
        if(ObjectFind(0, EA_OBJ_PREFIX + editPipsEntrada2ID) >= 0)
            PipsEntrada2 = (int)StringToInteger(ObjectGetString(0, EA_OBJ_PREFIX + editPipsEntrada2ID, OBJPROP_TEXT));
            
        if(ObjectFind(0, EA_OBJ_PREFIX + editTP2ID) >= 0)
            TP2Puntos = (int)StringToInteger(ObjectGetString(0, EA_OBJ_PREFIX + editTP2ID, OBJPROP_TEXT));
            
        if(ObjectFind(0, EA_OBJ_PREFIX + editNumEntradaID) >= 0)
        {
            string texto = ObjectGetString(0, EA_OBJ_PREFIX + editNumEntradaID, OBJPROP_TEXT);
            if(texto == "" || texto == "0")
                NumEntrada = 0;
            else
                NumEntrada = (int)StringToInteger(texto);
        }
            
        if(ObjectFind(0, EA_OBJ_PREFIX + editMinimaGID) >= 0)
            MinimaG = StringToDouble(ObjectGetString(0, EA_OBJ_PREFIX + editMinimaGID, OBJPROP_TEXT));
            
        if(ObjectFind(0, EA_OBJ_PREFIX + editNumCerrarID) >= 0)
        {
            string texto = ObjectGetString(0, EA_OBJ_PREFIX + editNumCerrarID, OBJPROP_TEXT);
            if(texto == "" || texto == "0")
                NumCerrar = 0;
            else
                NumCerrar = (int)StringToInteger(texto);
        }
        
        // Guardar expl√≠citamente estos valores
        GuardarValores();
        
        // Recrear la interfaz si es necesario
        CrearInterfaz();
        
        // Verificar y recrear √≥rdenes pendientes que puedan haberse perdido
        for(int i = 0; i < 10; i++)
        {
            if(secuencias[i].activa && secuencias[i].entradaPendienteActiva && !secuencias[i].cerradaManualmente)
            {
                Print("üîÑ Verificando orden pendiente para secuencia #", secuencias[i].id, " despu√©s de cambio de timeframe");
                secuencias[i].ultimaRecreacionPendiente = 0; // Forzar verificaci√≥n inmediata
                RecrearOrdenEntrada2(i);
            }
        }
        
        // Para evitar perder objetos dibujados manualmente, no hacer limpieza general
        return;
    }
    
    // Gesti√≥n de clics en botones
    if(id == CHARTEVENT_OBJECT_CLICK)
    {
        // Verificar si se ha hecho clic en uno de nuestros botones
        if(sparam == EA_OBJ_PREFIX + botonCompraID)
        {
            Print("Bot√≥n COMPRA presionado");
            ObjectSetInteger(0, EA_OBJ_PREFIX + botonCompraID, OBJPROP_STATE, false);
            
            // Limpiar secuencias fantasma antes de intentar iniciar una nueva
            LimpiarSecuenciasFantasma();
            
            // Iniciar secuencia sin restricci√≥n de l√≠mite
            IniciarSecuenciaCompra();
        }
        else if(sparam == EA_OBJ_PREFIX + botonVentaID)
        {
            Print("Bot√≥n VENTA presionado");
            ObjectSetInteger(0, EA_OBJ_PREFIX + botonVentaID, OBJPROP_STATE, false);
            
            // Limpiar secuencias fantasma antes de intentar iniciar una nueva
            LimpiarSecuenciasFantasma();
            
            // Iniciar secuencia sin restricci√≥n de l√≠mite
            IniciarSecuenciaVenta();
        }
    }
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
    // Si la interfaz no est√° creada, recrearla
    if(!interfazCreada) {
        CrearInterfaz();
        interfazCreada = true;
    }
    
    // Verificar √≥rdenes pendientes peri√≥dicamente
    VerificarOrdenesPendientes();
    
    // Nueva funci√≥n: Verificar secuencias sin √≥rdenes pendientes y cerrarlas
    VerificarCierrePorFaltaDePendientes();
    
    // Procesar cada secuencia activa
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tama√±o del array
    {
        if(!secuencias[i].activa) continue;

        // Si ya se detect√≥ TP, asegurarse de que todas las √≥rdenes est√©n cerradas
        if(secuencias[i].tpAlcanzado)
        {
            // Reintentar cierre si no se ha cerrado completamente
            if(!secuencias[i].cerradaCompletamente)
            {
                // Limitar la frecuencia de reintentos a cada 1 segundo
                if(TimeCurrent() - secuencias[i].ultimoCierreIntentado >= 1)
                {
                    Print("‚ö†Ô∏è Reintentando cierre para secuencia #", secuencias[i].id, 
                          " - Intento #", ++secuencias[i].intentosCierre);
                    secuencias[i].ultimoCierreIntentado = TimeCurrent();
                    
                    CerrarTodasLasOrdenesDeSecuencia(i);
                    
                    // Si ya se intent√≥ cerrar muchas veces, marcarla como cerrada de todos modos
                    if(secuencias[i].intentosCierre >= 5)
                    {
                        Print("üõë Alcanzado m√°ximo de intentos para secuencia #", secuencias[i].id, 
                              " - Marcando como cerrada");
                        secuencias[i].cerradaCompletamente = true;
                        secuencias[i].activa = false;
                        totalSecuencias--;
                    }
                }
            }
            continue;
        }
        // Verificaci√≥n de TP - cada tick para mayor precisi√≥n
        bool tpAlcanzado = false;
        
        // Verificar TPs en posiciones actuales (solo afecta a las entradas 1 y 2 que tienen TP)
        for(int j = 0; j < PositionsTotal(); j++)
        {
            ulong ticket = PositionGetTicket(j);
            if(!PositionSelectByTicket(ticket)) continue;
            
            string comentario = PositionGetString(POSITION_COMMENT);
            string secPrefix = "SEC" + IntegerToString(secuencias[i].id) + "_";
            
            // Si es una posici√≥n de esta secuencia
            if(StringFind(comentario, secPrefix) == 0)
            {
                double tp = PositionGetDouble(POSITION_TP);
                if(tp == 0) continue;  // Omitir posiciones sin TP
                
                double precioActual = PositionGetDouble(POSITION_PRICE_CURRENT);
                ENUM_POSITION_TYPE tipo = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
                
                // Verificar si est√° muy cerca o ha superado el TP (3 puntos para ser m√°s agresivo)
                if((tipo == POSITION_TYPE_BUY && precioActual >= tp - 3*_Point) ||
                   (tipo == POSITION_TYPE_SELL && precioActual <= tp + 3*_Point))
                {
                    tpAlcanzado = true;
                    Print("‚≠ê TP alcanzado o cercano en posici√≥n #", ticket, " - Secuencia #", secuencias[i].id);
                    break;
                }
            }
        }
        
        // Verificar historial de operaciones recientes para ver si se cerr√≥ alguna por TP
        if(!tpAlcanzado)
        {
            string secPrefix = "SEC" + IntegerToString(secuencias[i].id) + "_";
            
            datetime startTime = TimeCurrent() - 120; // Buscar en los √∫ltimos 2 minutos
            if(HistorySelect(startTime, TimeCurrent()))
            {
                for(int k = 0; k < HistoryDealsTotal(); k++)
                {
                    ulong dealTicket = HistoryDealGetTicket(k);
                    if(!HistoryDealSelect(dealTicket)) continue;
                    
                    string comentario = HistoryDealGetString(dealTicket, DEAL_COMMENT);
                    if(StringFind(comentario, secPrefix) == 0)
                    {
                        // Verificar si es un cierre de posici√≥n
                        if(HistoryDealGetInteger(dealTicket, DEAL_ENTRY) == DEAL_ENTRY_OUT)
                        {
                            double profit = HistoryDealGetDouble(dealTicket, DEAL_PROFIT);
                            ENUM_DEAL_REASON razon = (ENUM_DEAL_REASON)HistoryDealGetInteger(dealTicket, DEAL_REASON);
                            
                            // Si se cerr√≥ por TP o con beneficio
                            if(razon == DEAL_REASON_TP || profit > 0)
                            {
                                tpAlcanzado = true;
                                Print("‚≠ê TP detectado en historial - Deal #", dealTicket, " - Secuencia #", secuencias[i].id);
                                break;
                            }
                        }
                    }
                }
            }
        }
        
        // Si se alcanz√≥ TP, cerrar toda la secuencia
        if(tpAlcanzado)
        {
            secuencias[i].tpAlcanzado = true;
            secuencias[i].ultimoCierreIntentado = TimeCurrent();
            string tipoSecuencia = secuencias[i].esModoCompra ? "COMPRA" : "VENTA";
            Print("‚ö†Ô∏è TAKE PROFIT ALCANZADO - Secuencia #", secuencias[i].id, " (", tipoSecuencia, ") - CERRANDO TODAS LAS √ìRDENES");
            
            // Forzar cierre agresivo de todas las √≥rdenes inmediatamente usando el modo r√°pido
            CerrarTodasLasOrdenesDeSecuencia(i, true);
            CerrarSecuencia(i);
            
            // Actualizar el estado de las secuencias cuando se cierra una
            GuardarEstadoSecuencias();
            
            continue;
        }
        
        // AQU√ç: A√±adimos la llamada a nuestra nueva funci√≥n Reiubicar TPs y la funci√≥n de diagnosticar las secuencias.
        ReubicarTPsParaGarantiaMinimaG(i);
        DiagnosticarSecuencia(i); 

        // Si no se alcanz√≥ TP, verificar nuevas activaciones
        if(!secuencias[i].tpAlcanzado)
        {
            VerificarNuevasActivaciones(i);
        }
        
        // NUEVO: Verificar si se debe cerrar por n√∫mero de entrada
        VerificarCierrePorNumeroEntrada(i);
        
        // Verificar si necesitamos recrear la orden pendiente de Entrada #2
        if(secuencias[i].entradaPendienteActiva && secuencias[i].secuenciaActual == 2)
        {
            RecrearOrdenEntrada2(i);
        }
    }
    
    // Tambi√©n buscar √≥rdenes hu√©rfanas (sin secuencia asociada)
    LimpiarOrdenesHuerfanas();
}

//+------------------------------------------------------------------+
//| Verificar si se debe cerrar la secuencia por n√∫mero de entrada  |
//+------------------------------------------------------------------+
void VerificarCierrePorNumeroEntrada(int indiceSecuencia)
{
    // Verificar que la secuencia est√© activa
    if(!secuencias[indiceSecuencia].activa || secuencias[indiceSecuencia].tpAlcanzado)
        return;
    
    // Obtener el valor del campo "# Cerrar"
    string textoNumCerrar = ObjectGetString(0, EA_OBJ_PREFIX + editNumCerrarID, OBJPROP_TEXT);
    
    // Si el campo est√° vac√≠o o es "0", no cerrar por n√∫mero de entrada
    if(textoNumCerrar == "" || textoNumCerrar == "0")
        return;
    
    int numeroCerrar = (int)StringToInteger(textoNumCerrar);
    
    // Contar las posiciones activas de esta secuencia
    string secPrefix = "SEC" + IntegerToString(secuencias[indiceSecuencia].id) + "_";
    int posicionesActivas = 0;
    int numeroEntradaMasAlta = 0;
    
    // Contar posiciones y encontrar el n√∫mero de entrada m√°s alto
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        if(StringFind(comentario, secPrefix) == 0)
        {
            posicionesActivas++;
            
            // Extraer el n√∫mero de entrada del comentario
            int posENT = StringFind(comentario, "_ENT");
            if(posENT >= 0)
            {
                string numeroStr = StringSubstr(comentario, posENT + 4);
                int numeroEntrada = (int)StringToInteger(numeroStr);
                if(numeroEntrada > numeroEntradaMasAlta)
                    numeroEntradaMasAlta = numeroEntrada;
            }
        }
    }
    
    // Tambi√©n verificar en el historial reciente (√∫ltimos 10 segundos) por si la entrada se abri√≥ y cerr√≥ r√°pidamente
    datetime startTime = TimeCurrent() - 10;
    if(HistorySelect(startTime, TimeCurrent()))
    {
        for(int i = 0; i < HistoryDealsTotal(); i++)
        {
            ulong dealTicket = HistoryDealGetTicket(i);
            if(!HistoryDealSelect(dealTicket)) continue;
            
            string comentario = HistoryDealGetString(dealTicket, DEAL_COMMENT);
            if(StringFind(comentario, secPrefix) == 0)
            {
                // Si es una operaci√≥n de entrada (apertura)
                if(HistoryDealGetInteger(dealTicket, DEAL_ENTRY) == DEAL_ENTRY_IN)
                {
                    int posENT = StringFind(comentario, "_ENT");
                    if(posENT >= 0)
                    {
                        string numeroStr = StringSubstr(comentario, posENT + 4);
                        int numeroEntrada = (int)StringToInteger(numeroStr);
                        if(numeroEntrada > numeroEntradaMasAlta)
                            numeroEntradaMasAlta = numeroEntrada;
                    }
                }
            }
        }
    }
    
    // Si se alcanz√≥ o super√≥ el n√∫mero de entrada configurado, cerrar toda la secuencia
    if(numeroEntradaMasAlta >= numeroCerrar)
    {
        string tipoSecuencia = secuencias[indiceSecuencia].esModoCompra ? "COMPRA" : "VENTA";
        Print("üõë CIERRE POR N√öMERO DE ENTRADA #", numeroCerrar, " ALCANZADO - Secuencia #", 
              secuencias[indiceSecuencia].id, " (", tipoSecuencia, ") - CERRANDO TODAS LAS √ìRDENES");
        
        // Marcar para cierre
        secuencias[indiceSecuencia].tpAlcanzado = true;
        secuencias[indiceSecuencia].ultimoCierreIntentado = TimeCurrent();
        
        // Cerrar todas las √≥rdenes de la secuencia
        CerrarTodasLasOrdenesDeSecuencia(indiceSecuencia, true);
        CerrarSecuencia(indiceSecuencia);
        
        // Actualizar el estado
        GuardarEstadoSecuencias();
        
        Print("‚úÖ Secuencia #", secuencias[indiceSecuencia].id, 
              " cerrada por alcanzar entrada #", numeroCerrar);
    }
}

//+------------------------------------------------------------------+
//| Limpiar √≥rdenes hu√©rfanas (sin secuencia asociada)              |
//+------------------------------------------------------------------+
void LimpiarOrdenesHuerfanas()
{
    // Esta funci√≥n se ejecuta menos frecuentemente
    static datetime ultimaLimpieza = 0;
    if(TimeCurrent() - ultimaLimpieza < 30) return; // Solo cada 30 segundos
    
    ultimaLimpieza = TimeCurrent();
    
    // Buscar √≥rdenes pendientes con prefijo "SEC" pero sin secuencia activa
    for(int i = OrdersTotal() - 1; i >= 0; i--)
    {
        ulong ticket = OrderGetTicket(i);
        if(!OrderSelect(ticket)) continue;
        
        string comentario = OrderGetString(ORDER_COMMENT);
        if(StringFind(comentario, "SEC") == 0)
        {
            // Extraer el ID de secuencia
            int pos1 = StringFind(comentario, "SEC") + 3;
            int pos2 = StringFind(comentario, "_", pos1);
            if(pos2 == -1) continue;
            
            string idStr = StringSubstr(comentario, pos1, pos2 - pos1);
            int secId = (int)StringToInteger(idStr);
            
            // Verificar si la secuencia est√° activa
            bool secuenciaEncontrada = false;
            for(int j = 0; j < 10; j++)
            {
                if(secuencias[j].activa && secuencias[j].id == secId)
                {
                    secuenciaEncontrada = true;
                    break;
                }
            }
            
            // Si no se encontr√≥ una secuencia activa para esta orden, cerrarla
            if(!secuenciaEncontrada)
            {
                Print("üßπ Eliminando orden hu√©rfana #", ticket, " - Comentario: ", comentario);
                trade.OrderDelete(ticket);
            }
        }
    }
}

//+------------------------------------------------------------------+
//| Funci√≥n para resetear todas las secuencias (emergencia)          |
//+------------------------------------------------------------------+
void ResetearTodasLasSecuencias()
{
    Print("‚ö†Ô∏è REINICIO DE EMERGENCIA - Reseteando todas las secuencias");
    
    // Primero intenta cerrar todas las posiciones activas
    CerrarTodasLasSecuencias();
    
    // Luego resetear el estado de todas las secuencias
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tama√±o del array
    {
        ResetearSecuencia(i);
    }
    
    // Resetear el contador y el ID
    totalSecuencias = 0;
    proximoIDSecuencia = 1;
    
    // Guardar el estado
    GuardarEstadoSecuencias();
    
    Print("‚úÖ Reinicio de emergencia completado - Todas las secuencias han sido reseteadas");
}

//+------------------------------------------------------------------+
//| Funci√≥n para resetear el contador de secuencias activas         |
//+------------------------------------------------------------------+
void RecalcularTotalSecuencias()
{
    int contador = 0;
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tama√±o del array
    {
        if(secuencias[i].activa)
            contador++;
    }
    
    // Si el contador est√° inconsistente, arreglarlo
    if(contador != totalSecuencias)
    {
        Print("‚ö†Ô∏è Corrigiendo contador de secuencias: de ", totalSecuencias, " a ", contador);
        totalSecuencias = contador;
        GuardarEstadoSecuencias();
    }
}
//+------------------------------------------------------------------+
//| Funci√≥n para limpiar secuencias problem√°ticas                    |
//+------------------------------------------------------------------+
void LimpiarSecuenciasProblematicas()
{
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tama√±o del array
    {
        if(secuencias[i].activa)
        {
            // Verificar si hay actividad real (√≥rdenes o posiciones) para esta secuencia
            bool secuenciaValida = false;
            string secPrefix = "SEC" + IntegerToString(secuencias[i].id) + "_";
            
            // Comprobar posiciones
            for(int p = 0; p < PositionsTotal(); p++)
            {
                ulong ticket = PositionGetTicket(p);
                if(!PositionSelectByTicket(ticket)) continue;
                
                string comentario = PositionGetString(POSITION_COMMENT);
                if(StringFind(comentario, secPrefix) == 0)
                {
                    secuenciaValida = true;
                    break;
                }
            }
            
            // Comprobar √≥rdenes pendientes
            if(!secuenciaValida)
            {
                for(int o = 0; o < OrdersTotal(); o++)
                {
                    ulong ticket = OrderGetTicket(o);
                    if(!OrderSelect(ticket)) continue;
                    
                    string comentario = OrderGetString(ORDER_COMMENT);
                    if(StringFind(comentario, secPrefix) == 0)
                    {
                        secuenciaValida = true;
                        break;
                    }
                }
            }
            
            // Si no encontramos √≥rdenes ni posiciones, marcar como inactiva
            if(!secuenciaValida)
            {
                // Verificar en el historial reciente si hubo operaciones
                datetime startTime = TimeCurrent() - 300; // √öltimos 5 minutos
                bool existeEnHistorial = false;
                
                if(HistorySelect(startTime, TimeCurrent()))
                {
                    for(int h = 0; h < HistoryDealsTotal(); h++)
                    {
                        ulong dealTicket = HistoryDealGetTicket(h);
                        if(!HistoryDealSelect(dealTicket)) continue;
                        
                        string comentario = HistoryDealGetString(dealTicket, DEAL_COMMENT);
                        if(StringFind(comentario, secPrefix) == 0)
                        {
                            existeEnHistorial = true;
                            break;
                        }
                    }
                }
                
                if(!existeEnHistorial)
                {
                    Print("üßπ Limpiando secuencia #", secuencias[i].id, " - No se encontr√≥ actividad asociada");
                    secuencias[i].activa = false;
                    totalSecuencias--;
                }
            }
        }
    }
    
    // Guardar el estado actualizado
    GuardarEstadoSecuencias();
}

//+------------------------------------------------------------------+
//| Actualizar informaci√≥n de secuencias activas                     |
//+------------------------------------------------------------------+
void ActualizarInformacionSecuencias()
{
    // Eliminar la informaci√≥n anterior
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tama√±o del array
    {
        string labelId = EA_OBJ_PREFIX + "SecInfo_" + IntegerToString(i);
        string btnId = EA_OBJ_PREFIX + "BtnCerrarSec_" + IntegerToString(i);
        
        ObjectDelete(0, labelId);
        ObjectDelete(0, btnId);
    }
    
    // Posici√≥n inicial para la informaci√≥n
    int baseX = 30;
    int baseY = 230; // Ajustar seg√∫n la posici√≥n del panel de informaci√≥n
    int altoLinea = 20;
    int anchoBoton = 25;
    int margenBoton = 200;
    
    // T√≠tulo
    string tituloId = EA_OBJ_PREFIX + "SecInfoTitulo";
    ObjectCreate(0, tituloId, OBJ_LABEL, 0, 0, 0);
    ObjectSetInteger(0, tituloId, OBJPROP_XDISTANCE, baseX);
    ObjectSetInteger(0, tituloId, OBJPROP_YDISTANCE, baseY);
    ObjectSetString(0, tituloId, OBJPROP_TEXT, "Secuencias activas: " + IntegerToString(totalSecuencias));
    ObjectSetInteger(0, tituloId, OBJPROP_COLOR, clrYellow);
    ObjectSetInteger(0, tituloId, OBJPROP_FONTSIZE, 10);
    
    baseY += altoLinea + 5;
    
    // Mostrar secuencias activas
    int contadorSecuenciasActivas = 0;
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tama√±o del array
    {
        if(secuencias[i].activa)
        {
            string labelId = EA_OBJ_PREFIX + "SecInfo_" + IntegerToString(i);
            string btnId = EA_OBJ_PREFIX + "BtnCerrarSec_" + IntegerToString(i);
            string tipoSecuencia = secuencias[i].esModoCompra ? "COMPRA" : "VENTA";
            
            // Crear etiqueta con informaci√≥n de la secuencia
            ObjectCreate(0, labelId, OBJ_LABEL, 0, 0, 0);
            ObjectSetInteger(0, labelId, OBJPROP_XDISTANCE, baseX);
            ObjectSetInteger(0, labelId, OBJPROP_YDISTANCE, baseY + contadorSecuenciasActivas * altoLinea);
            ObjectSetString(0, labelId, OBJPROP_TEXT, "#" + IntegerToString(secuencias[i].id) + 
                             " - " + tipoSecuencia + " - Fase: " + IntegerToString(secuencias[i].secuenciaActual));
            ObjectSetInteger(0, labelId, OBJPROP_COLOR, secuencias[i].esModoCompra ? clrLime : clrRed);
            ObjectSetInteger(0, labelId, OBJPROP_FONTSIZE, 9);
            
            // Crear bot√≥n para cerrar la secuencia
            ObjectCreate(0, btnId, OBJ_BUTTON, 0, 0, 0);
            ObjectSetInteger(0, btnId, OBJPROP_XDISTANCE, baseX + margenBoton);
            ObjectSetInteger(0, btnId, OBJPROP_YDISTANCE, baseY + contadorSecuenciasActivas * altoLinea - 2);
            ObjectSetInteger(0, btnId, OBJPROP_XSIZE, anchoBoton);
            ObjectSetInteger(0, btnId, OBJPROP_YSIZE, 18);
            ObjectSetString(0, btnId, OBJPROP_TEXT, "X");
            ObjectSetInteger(0, btnId, OBJPROP_COLOR, clrWhite);
            ObjectSetInteger(0, btnId, OBJPROP_BGCOLOR, clrMaroon);
            ObjectSetInteger(0, btnId, OBJPROP_BORDER_COLOR, clrRed);
            
            contadorSecuenciasActivas++;
        }
    }
    
    ChartRedraw();
}

//+------------------------------------------------------------------+
//| Funci√≥n mejorada para verificar si una secuencia tiene √≥rdenes      |
//| pendientes evitando duplicados                                      |
//+------------------------------------------------------------------+
bool TieneOrdenesPendientes(int indice, bool &tieneMultiples)
{
    if(!secuencias[indice].activa) return false;
    
    string secPrefix = "SEC" + IntegerToString(secuencias[indice].id) + "_";
    int contadorOrdenes = 0;
    tieneMultiples = false;
    
    // Comprobar si hay √≥rdenes pendientes para esta secuencia
    for(int i = 0; i < OrdersTotal(); i++)
    {
        ulong ticket = OrderGetTicket(i);
        if(!OrderSelect(ticket)) continue;
        
        string comentario = OrderGetString(ORDER_COMMENT);
        if(StringFind(comentario, secPrefix) == 0)
        {
            contadorOrdenes++;
            if(contadorOrdenes > 1)
            {
                tieneMultiples = true;
                break;
            }
        }
    }
    
    return (contadorOrdenes > 0);
}

//+------------------------------------------------------------------+
//| Nueva funci√≥n para eliminar √≥rdenes pendientes duplicadas         |
//+------------------------------------------------------------------+
void EliminarOrdenesPendientesDuplicadas(int indice)
{
    if(!secuencias[indice].activa) return;
    
    string secPrefix = "SEC" + IntegerToString(secuencias[indice].id) + "_";
    string entradaActualPattern = "_ENT" + IntegerToString(secuencias[indice].secuenciaActual);
    
    // Preparar arrays para almacenar tickets de √≥rdenes por tipo
    int maxOrdenesPorTipo = 10; // Ajustar seg√∫n sea necesario
    ulong ticketsENT2[10];      // para √≥rdenes de entrada 2
    ulong ticketsEntradaActual[10]; // para √≥rdenes de la entrada actual 
    int contadorENT2 = 0;
    int contadorEntradaActual = 0;
    
    // Buscar y clasificar todas las √≥rdenes pendientes de la secuencia
    for(int i = 0; i < OrdersTotal(); i++)
    {
        ulong ticket = OrderGetTicket(i);
        if(!OrderSelect(ticket)) continue;
        
        string comentario = OrderGetString(ORDER_COMMENT);
        
        // Si pertenece a esta secuencia
        if(StringFind(comentario, secPrefix) == 0)
        {
            // Verificar si es una orden ENT2
            if(StringFind(comentario, "_ENT2") >= 0 && contadorENT2 < maxOrdenesPorTipo)
            {
                ticketsENT2[contadorENT2++] = ticket;
            }
            // Verificar si es una orden de la entrada actual
            else if(StringFind(comentario, entradaActualPattern) >= 0 && contadorEntradaActual < maxOrdenesPorTipo)
            {
                ticketsEntradaActual[contadorEntradaActual++] = ticket;
            }
        }
    }
    
    // Eliminar todas las √≥rdenes ENT2 duplicadas excepto la primera (si hay m√°s de una)
    if(contadorENT2 > 1)
    {
        Print("üîÑ Encontradas ", contadorENT2, " √≥rdenes ENT2 duplicadas para secuencia #", secuencias[indice].id, " - Eliminando extras");
        
        // Solo conservar la primera orden, eliminar las dem√°s
        for(int i = 1; i < contadorENT2; i++)
        {
            if(OrderSelect(ticketsENT2[i]) && trade.OrderDelete(ticketsENT2[i]))
            {
                Print("‚úÖ Eliminada orden ENT2 duplicada #", ticketsENT2[i], " para secuencia #", secuencias[indice].id);
            }
            else
            {
                Print("‚ùå Error al eliminar orden ENT2 duplicada #", ticketsENT2[i], ": ", GetLastError());
            }
        }
        
        // Actualizar el ticket de entrada2 con el ticket conservado
        if(OrderSelect(ticketsENT2[0]))
        {
            secuencias[indice].ticketEntrada2 = ticketsENT2[0];
            Print("üìù Actualizado ticket de entrada2 para secuencia #", secuencias[indice].id, " a: ", ticketsENT2[0]);
        }
    }
    
    // Eliminar todas las √≥rdenes de la entrada actual duplicadas excepto la primera (si hay m√°s de una)
    if(contadorEntradaActual > 1)
    {
        Print("üîÑ Encontradas ", contadorEntradaActual, " √≥rdenes entrada actual duplicadas para secuencia #", 
              secuencias[indice].id, " (Fase: ", secuencias[indice].secuenciaActual, ") - Eliminando extras");
              // Solo conservar la primera orden, eliminar las dem√°s
        for(int i = 1; i < contadorEntradaActual; i++)
        {
            if(OrderSelect(ticketsEntradaActual[i]) && trade.OrderDelete(ticketsEntradaActual[i]))
            {
                Print("‚úÖ Eliminada orden entrada duplicada #", ticketsEntradaActual[i], " para secuencia #", secuencias[indice].id);
            }
            else
            {
                Print("‚ùå Error al eliminar orden duplicada #", ticketsEntradaActual[i], ": ", GetLastError());
            }
        }
    }
}

//+------------------------------------------------------------------+
//| Calcular comisi√≥n de Pepperstone EUR/USD basada en volumen       |
//+------------------------------------------------------------------+
double CalcularComisionPepperstone(double volumen)
{
    // Tabla de comisiones Pepperstone EUR/USD (basada en datos proporcionados)
    double comision = 0.0;
    
    if(volumen <= 0) return 0.0;
    
    // Para vol√∫menes peque√±os, usar tabla exacta
    if(volumen <= 0.01) comision = 0.06;
    else if(volumen <= 0.02) comision = 0.1;
    else if(volumen <= 0.03) comision = 0.16;
    else if(volumen <= 0.04) comision = 0.2;
    else if(volumen <= 0.05) comision = 0.26;
    else if(volumen <= 0.06) comision = 0.32;
    else if(volumen <= 0.07) comision = 0.38;  // CORREGIDO: era 0.36, debe ser 0.38
    else if(volumen <= 0.08) comision = 0.42;
    else if(volumen <= 0.09) comision = 0.46;
    else if(volumen <= 0.10) comision = 0.52;
    else if(volumen <= 0.11) comision = 0.58;  // NUEVO
    else if(volumen <= 0.12) comision = 0.62;  // NUEVO
    else if(volumen <= 0.13) comision = 0.68;  // NUEVO
    else if(volumen <= 0.14) comision = 0.72;  // NUEVO
    else if(volumen <= 0.15) comision = 0.78;  // NUEVO
    else if(volumen <= 0.16) comision = 0.84;  // NUEVO
    else if(volumen <= 0.17) comision = 0.88;  // NUEVO
    else if(volumen <= 0.18) comision = 0.94;  // NUEVO
    else if(volumen <= 0.19) comision = 0.98;  // NUEVO
    else if(volumen <= 0.20) comision = 1.04;  // NUEVO
    else if(volumen <= 0.30) comision = volumen * 5.2;  // Para 0.21 a 0.30
    else
    {
        // Para vol√∫menes mayores, usar la f√≥rmula exacta: 5.2 EUR por lote
        comision = volumen * 5.2;
    }
    
    return comision;
}

//+------------------------------------------------------------------+
//| FUNCI√ìN CORREGIDA PARA REUBICAR TPs CON GANANCIA EXACTA          |
//| Mantiene la l√≥gica iterativa original pero con precisi√≥n mejorada|
//+------------------------------------------------------------------+
//+------------------------------------------------------------------+
//| Funci√≥n auxiliar para calcular P&L total dado un precio TP      |
//+------------------------------------------------------------------+
double CalcularPLTotalConTP(int indiceSecuencia, double precioTP)
{
    double plTotal = 0;
    string secPrefix = "SEC" + IntegerToString(secuencias[indiceSecuencia].id) + "_";
    
    // Obtener spread y valor pip
    double spread = SymbolInfoInteger(_Symbol, SYMBOL_SPREAD) * _Point;
    double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double valorPipEUR = 10.0 / bid;
    
    // Recorrer todas las posiciones de la secuencia
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        if(StringFind(comentario, secPrefix) != 0) continue;
        
        double lotes = PositionGetDouble(POSITION_VOLUME);
        int tipo = (int)PositionGetInteger(POSITION_TYPE);
        double precioApertura = PositionGetDouble(POSITION_PRICE_OPEN);
        
        double precioCierre = precioTP;
        
        // IMPORTANTE: Las posiciones SELL se cierran al ASK (precio + spread)
        if(tipo == POSITION_TYPE_SELL)
        {
            precioCierre = precioTP + spread;
        }
        
        // Calcular diferencia en pips
        double diferenciaPips = 0;
        if(tipo == POSITION_TYPE_BUY)
        {
            diferenciaPips = (precioCierre - precioApertura) / 0.0001;
        }
        else // SELL
        {
            diferenciaPips = (precioApertura - precioCierre) / 0.0001;
        }
        
        // Convertir a EUR
        plTotal += diferenciaPips * lotes * valorPipEUR;
    }
    
    return plTotal;
}

//+------------------------------------------------------------------+
//| Reubicar TPs para garantizar una ganancia EXACTA                |
//+------------------------------------------------------------------+
//+------------------------------------------------------------------+
//| Reubicar TPs para garantizar una ganancia EXACTA                |
//+------------------------------------------------------------------+
void ReubicarTPsParaGarantiaMinimaG(int indiceSecuencia)
{
    // Verificar que la secuencia est√© activa
    if(!secuencias[indiceSecuencia].activa || secuencias[indiceSecuencia].tpAlcanzado)
        return;
        
    // Obtener el n√∫mero de entrada en el que se debe activar la reubicaci√≥n
    string textoNumEntrada = ObjectGetString(0, EA_OBJ_PREFIX + editNumEntradaID, OBJPROP_TEXT);
    
    // NUEVO: Si el campo est√° vac√≠o o es "0", no activar la reubicaci√≥n
    if(textoNumEntrada == "" || textoNumEntrada == "0")
    {
        return; // No reubicar TPs si no hay valor o es 0
    }
    
    int numeroEntradaActivacion = (int)StringToInteger(textoNumEntrada);
    
    // CONTAR posiciones REALES activadas
    string secPrefix = "SEC" + IntegerToString(secuencias[indiceSecuencia].id) + "_";
    int posicionesActivasReales = 0;
    
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        if(StringFind(comentario, secPrefix) == 0)
        {
            posicionesActivasReales++;
        }
    }
    
    // Verificar condici√≥n de activaci√≥n
    if(posicionesActivasReales < numeroEntradaActivacion)
        return;
    
    // Obtener la ganancia EXACTA deseada - VALIDACI√ìN MEJORADA
    string textoMinimaG = ObjectGetString(0, EA_OBJ_PREFIX + editMinimaGID, OBJPROP_TEXT);
    double gananciaExacta = StringToDouble(textoMinimaG);
    
    Print("\n‚ö†Ô∏è VALIDACI√ìN DE CONFIGURACI√ìN:");
    Print("   Texto en Minima G.: '", textoMinimaG, "'");
    Print("   Valor interpretado: ", DoubleToString(gananciaExacta, 2), " EUR");
    
    if(gananciaExacta <= 0)
    {
        Print("‚ùå Ganancia inv√°lida o cero");
        return;
    }
    
    Print("\n========== REC√ÅLCULO DE TPs PARA GANANCIA EXACTA ==========");
    Print("üéØ Ganancia objetivo: ", DoubleToString(gananciaExacta, 2), " EUR");
    Print("üìä Secuencia #", secuencias[indiceSecuencia].id, " - Posiciones activas: ", posicionesActivasReales);
    
    // Arrays para almacenar informaci√≥n
    ulong ticketsPos[50];
    double lotesPos[50];
    int tiposPos[50];
    double preciosAperturaPos[50];
    string comentariosPos[50];
    double tpActualPos[50];
    int totalPosiciones = 0;
    
    int indiceEnt1 = -1;
    int indiceEnt2 = -1;
    
    double totalComisiones = 0;
    
    // Recolectar todas las posiciones
    Print("\nüìã POSICIONES ACTUALES:");
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        
        if(StringFind(comentario, secPrefix) == 0)
        {
            ticketsPos[totalPosiciones] = ticket;
            lotesPos[totalPosiciones] = PositionGetDouble(POSITION_VOLUME);
            tiposPos[totalPosiciones] = (int)PositionGetInteger(POSITION_TYPE);
            preciosAperturaPos[totalPosiciones] = PositionGetDouble(POSITION_PRICE_OPEN);
            tpActualPos[totalPosiciones] = PositionGetDouble(POSITION_TP);
            comentariosPos[totalPosiciones] = comentario;
            
            // Acumular comisiones usando la funci√≥n corregida
            totalComisiones += CalcularComisionPepperstone(lotesPos[totalPosiciones]);
            
            // Identificar ENT1 y ENT2
            if(StringFind(comentario, "ENT1") >= 0)
            {
                indiceEnt1 = totalPosiciones;
            }
            if(StringFind(comentario, "ENT2") >= 0)
            {
                indiceEnt2 = totalPosiciones;
            }
            
            Print("  #", ticket, " ", comentario, " ",
                  (tiposPos[totalPosiciones] == POSITION_TYPE_BUY ? "BUY" : "SELL"),
                  " ", DoubleToString(lotesPos[totalPosiciones], 2), " @ ",
                  DoubleToString(preciosAperturaPos[totalPosiciones], _Digits),
                  " TP actual: ", DoubleToString(tpActualPos[totalPosiciones], _Digits));
            
            totalPosiciones++;
        }
    }
    
    if(totalPosiciones == 0 || (indiceEnt1 < 0 && indiceEnt2 < 0))
    {
        Print("‚ùå No se encontraron posiciones v√°lidas o ENT1/ENT2");
        return;
    }
    
    Print("\nüí∏ Comisi√≥n total: ", DoubleToString(totalComisiones, 2), " EUR");
    
    // Obtener datos del mercado
    double spread = SymbolInfoInteger(_Symbol, SYMBOL_SPREAD) * _Point;
    double tasaEURUSD = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    
    // Para EUR/USD con cuenta en EUR
    double valorPorPipPorLote = 10.0 / tasaEURUSD;
    
    Print("üìä Spread actual: ", DoubleToString(spread/_Point, 1), " puntos");
    Print("üí± EUR/USD: ", DoubleToString(tasaEURUSD, _Digits));
    Print("üí∞ Valor pip/lote: ", DoubleToString(valorPorPipPorLote, 4), " EUR");
    
    // Ganancia objetivo incluyendo comisiones
    double gananciaObjetivo = gananciaExacta + totalComisiones;
    Print("üéØ Ganancia objetivo total (con comisiones): ", DoubleToString(gananciaObjetivo, 2), " EUR");
    
    // IMPORTANTE: Ajuste para m√∫ltiples entradas
    // Con 3+ entradas, necesitamos ser m√°s precisos con el c√°lculo del spread
    
    // Contar posiciones SELL para ajuste de spread
    int totalSells = 0;
    double totalLotesSell = 0;
    for(int i = 0; i < totalPosiciones; i++)
    {
        if(tiposPos[i] == POSITION_TYPE_SELL)
        {
            totalSells++;
            totalLotesSell += lotesPos[i];
        }
    }
    
    Print("üìä Total SELL: ", totalSells, " posiciones, ", DoubleToString(totalLotesSell, 2), " lotes");
    
    // Para TP1 (si existe ENT1)
    if(indiceEnt1 >= 0)
    {
        Print("\nüìê CALCULANDO TP1 (ENT1 es ", (tiposPos[indiceEnt1] == POSITION_TYPE_BUY ? "BUY" : "SELL"), ")...");
        
        // Calcular el precio objetivo usando m√©todo directo
        double sumaNumerador = gananciaObjetivo;
        double sumaDenominador = 0;
        
        // Para cada posici√≥n, calcular su contribuci√≥n
        for(int i = 0; i < totalPosiciones; i++)
        {
            double factor = lotesPos[i] * 10000 * valorPorPipPorLote;
            
            if(tiposPos[i] == POSITION_TYPE_BUY)
            {
                // BUY: ganancia = (precioCierre - precioApertura) * factor
                sumaDenominador += factor;
                sumaNumerador += preciosAperturaPos[i] * factor;
            }
            else
            {
                // SELL: ganancia = (precioApertura - precioCierreConSpread) * factor
                // precioCierreConSpread = precioCierre + spread
                sumaDenominador -= factor;
                sumaNumerador -= preciosAperturaPos[i] * factor;
                sumaNumerador += spread * factor; // Ajuste por spread
            }
        }
        
        if(MathAbs(sumaDenominador) < 0.001)
        {
            Print("‚ùå No se puede calcular TP1 - denominador muy peque√±o");
        }
        else
        {
            double nuevoTP1 = sumaNumerador / sumaDenominador;
            nuevoTP1 = NormalizeDouble(nuevoTP1, _Digits);
            
            // Validar que el TP sea razonable
            double precioActual = SymbolInfoDouble(_Symbol, SYMBOL_BID);
            double distancia = MathAbs(nuevoTP1 - precioActual);
            
            if(distancia < 5 * _Point || distancia > 1000 * _Point)
            {
                Print("‚ö†Ô∏è TP1 calculado fuera de rango razonable: ", DoubleToString(nuevoTP1, _Digits));
                Print("   Distancia: ", DoubleToString(distancia/_Point, 0), " puntos");
            }
            else
            {
                Print("‚úÖ Nuevo TP1 calculado: ", DoubleToString(nuevoTP1, _Digits));
                
                // Verificar el c√°lculo
                double verificacionPL = 0;
                for(int i = 0; i < totalPosiciones; i++)
                {
                    double precioCierre = nuevoTP1;
                    if(tiposPos[i] == POSITION_TYPE_SELL)
                        precioCierre += spread; // SELL se cierra al ASK
                    
                    double pips = 0;
                    if(tiposPos[i] == POSITION_TYPE_BUY)
                        pips = (precioCierre - preciosAperturaPos[i]) / 0.0001;
                    else
                        pips = (preciosAperturaPos[i] - precioCierre) / 0.0001;
                    
                    double gananciaPos = pips * lotesPos[i] * valorPorPipPorLote;
                    verificacionPL += gananciaPos;
                }
                
                Print("üìä Verificaci√≥n TP1:");
                Print("   P&L bruto: ", DoubleToString(verificacionPL, 2), " EUR");
                Print("   Comisiones: ", DoubleToString(totalComisiones, 2), " EUR");
                Print("   P&L neto: ", DoubleToString(verificacionPL - totalComisiones, 2), " EUR");
                Print("   Objetivo: ", DoubleToString(gananciaExacta, 2), " EUR");
                Print("   Diferencia: ", DoubleToString((verificacionPL - totalComisiones) - gananciaExacta, 4), " EUR");
                
                // Modificar TP1
                if(trade.PositionModify(ticketsPos[indiceEnt1], 0, nuevoTP1))
                {
                    Print("‚úÖ TP1 modificado exitosamente");
                    secuencias[indiceSecuencia].tp1Precio = nuevoTP1;
                }
                else
                {
                    Print("‚ùå Error al modificar TP1: ", GetLastError());
                }
            }
        }
    }
    
    // Para TP2 (mismo proceso)
    if(indiceEnt2 >= 0)
    {
        Print("\nüìê CALCULANDO TP2 (ENT2 es ", (tiposPos[indiceEnt2] == POSITION_TYPE_BUY ? "BUY" : "SELL"), ")...");
        
        double sumaNumerador = gananciaObjetivo;
        double sumaDenominador = 0;
        
        for(int i = 0; i < totalPosiciones; i++)
        {
            double factor = lotesPos[i] * 10000 * valorPorPipPorLote;
            
            if(tiposPos[i] == POSITION_TYPE_BUY)
            {
                sumaDenominador += factor;
                sumaNumerador += preciosAperturaPos[i] * factor;
            }
            else
            {
                sumaDenominador -= factor;
                sumaNumerador -= preciosAperturaPos[i] * factor;
                sumaNumerador += spread * factor;
            }
        }
        
        if(MathAbs(sumaDenominador) < 0.001)
        {
            Print("‚ùå No se puede calcular TP2 - denominador muy peque√±o");
        }
        else
        {
            double nuevoTP2 = sumaNumerador / sumaDenominador;
            nuevoTP2 = NormalizeDouble(nuevoTP2, _Digits);
            
            double precioActual = SymbolInfoDouble(_Symbol, SYMBOL_BID);
            double distancia = MathAbs(nuevoTP2 - precioActual);
            
            if(distancia < 5 * _Point || distancia > 1000 * _Point)
            {
                Print("‚ö†Ô∏è TP2 calculado fuera de rango razonable: ", DoubleToString(nuevoTP2, _Digits));
            }
            else
            {
                Print("‚úÖ Nuevo TP2 calculado: ", DoubleToString(nuevoTP2, _Digits));
                
                // Verificar
                double verificacionPL = 0;
                for(int i = 0; i < totalPosiciones; i++)
                {
                    double precioCierre = nuevoTP2;
                    if(tiposPos[i] == POSITION_TYPE_SELL)
                        precioCierre += spread;
                    
                    double pips = 0;
                    if(tiposPos[i] == POSITION_TYPE_BUY)
                        pips = (precioCierre - preciosAperturaPos[i]) / 0.0001;
                    else
                        pips = (preciosAperturaPos[i] - precioCierre) / 0.0001;
                    
                    double gananciaPos = pips * lotesPos[i] * valorPorPipPorLote;
                    verificacionPL += gananciaPos;
                }
                
                Print("üìä Verificaci√≥n TP2:");
                Print("   P&L neto: ", DoubleToString(verificacionPL - totalComisiones, 2), " EUR");
                Print("   Objetivo: ", DoubleToString(gananciaExacta, 2), " EUR");
                
                if(trade.PositionModify(ticketsPos[indiceEnt2], 0, nuevoTP2))
                {
                    Print("‚úÖ TP2 modificado exitosamente");
                    secuencias[indiceSecuencia].tp2Precio = nuevoTP2;
                }
            }
        }
    }
    
    GuardarEstadoSecuencias();
    Print("========== FIN DE REC√ÅLCULO ==========\n");
}

//+------------------------------------------------------------------+
//| Funci√≥n de diagn√≥stico para verificar c√°lculos                   |
//+------------------------------------------------------------------+
void DiagnosticarSecuencia(int indiceSecuencia)
{
    if(!secuencias[indiceSecuencia].activa) return;
    
    string secPrefix = "SEC" + IntegerToString(secuencias[indiceSecuencia].id) + "_";
    
    Print("\n========== DIAGN√ìSTICO SECUENCIA #", secuencias[indiceSecuencia].id, " ==========");
    
    // Recolectar todas las posiciones
    double totalComisiones = 0;
    double totalPL = 0;
    int numPosiciones = 0;
    
    Print("POSICIONES ABIERTAS:");
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        if(StringFind(comentario, secPrefix) == 0)
        {
            double lotes = PositionGetDouble(POSITION_VOLUME);
            double precioApertura = PositionGetDouble(POSITION_PRICE_OPEN);
            double tp = PositionGetDouble(POSITION_TP);
            double pl = PositionGetDouble(POSITION_PROFIT);
            string tipo = (PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY) ? "BUY" : "SELL";
            
            totalComisiones += CalcularComisionPepperstone(lotes);
            totalPL += pl;
            
            Print("  #", ticket, " ", tipo, " ", DoubleToString(lotes, 2), 
                  " @ ", DoubleToString(precioApertura, _Digits),
                  " TP=", DoubleToString(tp, _Digits),
                  " P/L=", DoubleToString(pl, 2));
            
            numPosiciones++;
        }
    }
    
    double gananciaActualNeta = totalPL - totalComisiones;
    
    Print("\nRESUMEN:");
    Print("  Posiciones: ", numPosiciones);
    Print("  P/L Bruto: ", DoubleToString(totalPL, 2), " EUR");
    Print("  Comisiones: ", DoubleToString(totalComisiones, 2), " EUR");
    Print("  P/L Neto: ", DoubleToString(gananciaActualNeta, 2), " EUR");
    Print("  Ganancia objetivo: ", DoubleToString(StringToDouble(ObjectGetString(0, EA_OBJ_PREFIX + editMinimaGID, OBJPROP_TEXT)), 2), " EUR");
    
    // Simular cierre a precio actual
    double precioActual = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double plSimulado = 0;
    
    Print("\nSIMULACI√ìN DE CIERRE AL PRECIO ACTUAL (", DoubleToString(precioActual, _Digits), "):");
    
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        if(StringFind(comentario, secPrefix) == 0)
        {
            double lotes = PositionGetDouble(POSITION_VOLUME);
            double precioApertura = PositionGetDouble(POSITION_PRICE_OPEN);
            int tipo = (int)PositionGetInteger(POSITION_TYPE);
            
            double pips = 0;
            if(tipo == POSITION_TYPE_BUY)
                pips = (precioActual - precioApertura) / 0.0001;
            else
                pips = (precioApertura - precioActual) / 0.0001;
            
            double ganancia = pips * lotes * 10.0 / SymbolInfoDouble(_Symbol, SYMBOL_BID);
            plSimulado += ganancia;
            
            Print("  #", ticket, " ", (tipo == POSITION_TYPE_BUY ? "BUY" : "SELL"),
                  " ", DoubleToString(lotes, 2), " = ", DoubleToString(ganancia, 2), " EUR");
        }
    }
    
    Print("\n  P/L Simulado Bruto: ", DoubleToString(plSimulado, 2), " EUR");
    Print("  Comisiones: ", DoubleToString(totalComisiones, 2), " EUR");
    Print("  P/L Simulado Neto: ", DoubleToString(plSimulado - totalComisiones, 2), " EUR");
    Print("=====================================\n");
}

//+------------------------------------------------------------------+
//| Funci√≥n para limpiar secuencias fantasma silenciosamente         |
//+------------------------------------------------------------------+
void LimpiarSecuenciasFantasma()
{
    int contadorLimpiadas = 0;
    
    // Primero, recalcular el total para asegurar que es correcto
    RecalcularTotalSecuencias();
    
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tama√±o del array
    {
        if(secuencias[i].activa)
        {
            // Verificar si hay actividad real (√≥rdenes o posiciones) para esta secuencia
            bool secuenciaValida = false;
            string secPrefix = "SEC" + IntegerToString(secuencias[i].id) + "_";
            
            // Comprobar posiciones
            for(int p = 0; p < PositionsTotal(); p++)
            {
                ulong ticket = PositionGetTicket(p);
                if(!PositionSelectByTicket(ticket)) continue;
                
                string comentario = PositionGetString(POSITION_COMMENT);
                if(StringFind(comentario, secPrefix) == 0)
                {
                    secuenciaValida = true;
                    break;
                }
            }
            
            // Comprobar √≥rdenes pendientes
            if(!secuenciaValida)
            {
                for(int o = 0; o < OrdersTotal(); o++)
                {
                    ulong ticket = OrderGetTicket(o);
                    if(!OrderSelect(ticket)) continue;
                    
                    string comentario = OrderGetString(ORDER_COMMENT);
                    if(StringFind(comentario, secPrefix) == 0)
                    {
                        secuenciaValida = true;
                        break;
                    }
                }
            }
            
            // Si no encontramos √≥rdenes ni posiciones, marcar como inactiva
            if(!secuenciaValida)
            {
                // Verificar en el historial reciente si hubo operaciones
                datetime startTime = TimeCurrent() - 300; // √öltimos 5 minutos
                bool existeEnHistorial = false;
                
                if(HistorySelect(startTime, TimeCurrent()))
                {
                    for(int h = 0; h < HistoryDealsTotal(); h++)
                    {
                        ulong dealTicket = HistoryDealGetTicket(h);
                        if(!HistoryDealSelect(dealTicket)) continue;
                        
                        string comentario = HistoryDealGetString(dealTicket, DEAL_COMMENT);
                        if(StringFind(comentario, secPrefix) == 0)
                        {
                            existeEnHistorial = true;
                            break;
                        }
                    }
                }
                
                if(!existeEnHistorial)
                {
                    Print("üßπ Limpieza autom√°tica: Secuencia #", secuencias[i].id, " sin actividad detectada");
                    secuencias[i].activa = false;
                    totalSecuencias--;
                    contadorLimpiadas++;
                }
            }
        }
    }
    
    if(contadorLimpiadas > 0)
    {
        Print("üßπ Limpiadas ", contadorLimpiadas, " secuencias fantasma. Total activas ahora: ", totalSecuencias);
        GuardarEstadoSecuencias();
    }
}


//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
    // Inicializar con ID 1, pero luego comprobar si hay que restaurar el contador
    proximoIDSecuencia = 1;
    
    // Verificar si el trading est√° permitido
    if(!TerminalInfoInteger(TERMINAL_TRADE_ALLOWED))
    {
        Alert("El trading autom√°tico no est√° permitido en el terminal");
        return INIT_FAILED;
    }
    
    if(!AccountInfoInteger(ACCOUNT_TRADE_EXPERT))
    {
        Alert("El trading con EAs no est√° permitido en esta cuenta");
        return INIT_FAILED;
    }
    
    trade.SetDeviationInPoints(10);
    
    // Inicializar la interfaz
    CrearInterfaz();
    
    // Inicializar array de secuencias
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tama√±o del array
    {
        ResetearSecuencia(i);
    }
    
    // Nueva funci√≥n: Restaurar las √≥rdenes pendientes perdidas en cambios de timeframe
    RecuperarOrdenesPendientes();
    
    // Habilitar eventos de gr√°fico para botones (ya est√°n habilitados por defecto)
    ChartRedraw(); // Aseguramos que el gr√°fico se redibuja para mostrar la interfaz
    
    return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
    // Guardar valores de los controles antes de destruirlos
    GuardarValores();
    
    // Si la raz√≥n de deinicializaci√≥n es cambio de temporalidad o cierre del gr√°fico,
    // guardar el estado y el contador de secuencias
    if(reason == REASON_CHARTCHANGE || reason == REASON_CHARTCLOSE)
    {
        // No eliminar los objetos, solo guardar el estado
        Print("Cambio de temporalidad detectado - Preservando objetos y contador de secuencias");
        
        // Guardar estado e ID de pr√≥xima secuencia para mantener numeraci√≥n
        GuardarEstadoSecuenciasConID();
        return;
    }
    
    // Si se trata de eliminaci√≥n del EA, limpiar todas las secuencias activas
    // Y no preservar el contador (para que se reinicie la pr√≥xima vez)
    if(reason == REASON_REMOVE)
    {
        Print("Eliminando EA - Cerrando todas las secuencias activas");
        CerrarTodasLasSecuencias();
        
        // Borrar la variable global que guarda el pr√≥ximo ID para forzar reinicio
        GlobalVariableDel("EA_PROXIMO_ID_SECUENCIA_" + Symbol());
    }
    
    // Para otras razones, eliminar solo los objetos del EA
    ObjectsDeleteAll(0, EA_OBJ_PREFIX);
    Print("EA deinicializado - Objetos del EA eliminados");
}

//+------------------------------------------------------------------+
//| Guardar estado de secuencias incluyendo el pr√≥ximo ID            |
//+------------------------------------------------------------------+
void GuardarEstadoSecuenciasConID()
{
    // Guardar el n√∫mero total de secuencias activas
    GlobalVariableSet("EA_TOTAL_SECUENCIAS_" + Symbol(), totalSecuencias);
    
    // Guardar el pr√≥ximo ID de secuencia para mantener la numeraci√≥n entre cambios de timeframe
    GlobalVariableSet("EA_PROXIMO_ID_SECUENCIA_" + Symbol(), proximoIDSecuencia);
    
    // Guardar informaci√≥n detallada de cada secuencia activa
    for(int i = 0; i < 20; i++)
    {
        if(secuencias[i].activa)
        {
            string baseKey = "EA_SEC_" + Symbol() + "_" + IntegerToString(i) + "_";
            
            GlobalVariableSet(baseKey + "ID", secuencias[i].id);
            GlobalVariableSet(baseKey + "ACTIVA", 1);
            GlobalVariableSet(baseKey + "PRECIO_E1", secuencias[i].precioEntrada1);
            GlobalVariableSet(baseKey + "PRECIO_E2", secuencias[i].precioEntrada2);
            GlobalVariableSet(baseKey + "TP1", secuencias[i].tp1Precio);
            GlobalVariableSet(baseKey + "TP2", secuencias[i].tp2Precio);
            GlobalVariableSet(baseKey + "SEQ_ACTUAL", secuencias[i].secuenciaActual);
            GlobalVariableSet(baseKey + "ES_COMPRA", secuencias[i].esModoCompra ? 1 : 0);
            GlobalVariableSet(baseKey + "TICKET_E1", secuencias[i].ticketEntrada1);
            GlobalVariableSet(baseKey + "TICKET_E2", secuencias[i].ticketEntrada2);
            GlobalVariableSet(baseKey + "PENDIENTE_ACTIVA", secuencias[i].entradaPendienteActiva ? 1 : 0);
            GlobalVariableSet(baseKey + "CERRADA_MANUAL", secuencias[i].cerradaManualmente ? 1 : 0);
            GlobalVariableSet(baseKey + "TP_REUBICADO", secuencias[i].tpReubicado ? 1 : 0);
            
            Print("Guardado estado de secuencia #", secuencias[i].id, " para persistencia entre timeframes");
        }
    }
}

//+------------------------------------------------------------------+
//| Guardar estado b√°sico de secuencias sin ID                       |
//+------------------------------------------------------------------+
void GuardarEstadoSecuencias()
{
    // Guardar el n√∫mero total de secuencias activas
    GlobalVariableSet("EA_TOTAL_SECUENCIAS_" + Symbol(), totalSecuencias);
    
    // Guardar informaci√≥n detallada de cada secuencia activa
    for(int i = 0; i < 20; i++)
    {
        if(secuencias[i].activa)
        {
            string baseKey = "EA_SEC_" + Symbol() + "_" + IntegerToString(i) + "_";
            
            GlobalVariableSet(baseKey + "ID", secuencias[i].id);
            GlobalVariableSet(baseKey + "ACTIVA", 1);
            GlobalVariableSet(baseKey + "PRECIO_E1", secuencias[i].precioEntrada1);
            GlobalVariableSet(baseKey + "PRECIO_E2", secuencias[i].precioEntrada2);
            GlobalVariableSet(baseKey + "TP1", secuencias[i].tp1Precio);
            GlobalVariableSet(baseKey + "TP2", secuencias[i].tp2Precio);
            GlobalVariableSet(baseKey + "SEQ_ACTUAL", secuencias[i].secuenciaActual);
            GlobalVariableSet(baseKey + "ES_COMPRA", secuencias[i].esModoCompra ? 1 : 0);
            GlobalVariableSet(baseKey + "TICKET_E1", secuencias[i].ticketEntrada1);
            GlobalVariableSet(baseKey + "TICKET_E2", secuencias[i].ticketEntrada2);
            GlobalVariableSet(baseKey + "PENDIENTE_ACTIVA", secuencias[i].entradaPendienteActiva ? 1 : 0);
            GlobalVariableSet(baseKey + "CERRADA_MANUAL", secuencias[i].cerradaManualmente ? 1 : 0);
            GlobalVariableSet(baseKey + "TP_REUBICADO", secuencias[i].tpReubicado ? 1 : 0); // A√ëADIR ESTA L√çNEA
        }
    }
}

//+------------------------------------------------------------------+
//| Restaurar estado de las secuencias                               |
//+------------------------------------------------------------------+
void RestaurarEstadoSecuencias()
{
    // Verificar si hay secuencias guardadas
    if(!GlobalVariableCheck("EA_TOTAL_SECUENCIAS_" + Symbol()))
        return;
        
    int totalSecuenciasGuardadas = (int)GlobalVariableGet("EA_TOTAL_SECUENCIAS_" + Symbol());
    
    // Restaurar el pr√≥ximo ID de secuencia solo si fue un cambio de temporalidad
    // (Comprobamos si la variable existe y si hay secuencias que restaurar)
    if(GlobalVariableCheck("EA_PROXIMO_ID_SECUENCIA_" + Symbol()) && totalSecuenciasGuardadas > 0)
    {
        proximoIDSecuencia = (int)GlobalVariableGet("EA_PROXIMO_ID_SECUENCIA_" + Symbol());
        Print("Restaurado contador de IDs de secuencia desde cambio de temporalidad: ", proximoIDSecuencia);
    }
    
    if(totalSecuenciasGuardadas <= 0)
        return;
        
    Print("Restaurando ", totalSecuenciasGuardadas, " secuencias guardadas");
    
    // Restaurar informaci√≥n de cada secuencia guardada
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tama√±o del array
    {
        string baseKey = "EA_SEC_" + Symbol() + "_" + IntegerToString(i) + "_";
        
        // Verificar si esta secuencia estaba activa
        if(GlobalVariableCheck(baseKey + "ACTIVA") && GlobalVariableGet(baseKey + "ACTIVA") == 1)
        {
            secuencias[i].id = (int)GlobalVariableGet(baseKey + "ID");
            secuencias[i].activa = true;
            secuencias[i].precioEntrada1 = GlobalVariableGet(baseKey + "PRECIO_E1");
            secuencias[i].precioEntrada2 = GlobalVariableGet(baseKey + "PRECIO_E2");
            secuencias[i].tp1Precio = GlobalVariableGet(baseKey + "TP1");
            secuencias[i].tp2Precio = GlobalVariableGet(baseKey + "TP2");
            secuencias[i].secuenciaActual = (int)GlobalVariableGet(baseKey + "SEQ_ACTUAL");
            secuencias[i].esModoCompra = (GlobalVariableGet(baseKey + "ES_COMPRA") == 1);
            secuencias[i].ticketEntrada1 = (ulong)GlobalVariableGet(baseKey + "TICKET_E1");
            secuencias[i].ticketEntrada2 = (ulong)GlobalVariableGet(baseKey + "TICKET_E2");
            secuencias[i].entradaPendienteActiva = (GlobalVariableGet(baseKey + "PENDIENTE_ACTIVA") == 1);
            secuencias[i].cerradaManualmente = GlobalVariableCheck(baseKey + "CERRADA_MANUAL") ? 
                                              (GlobalVariableGet(baseKey + "CERRADA_MANUAL") == 1) : false;
            secuencias[i].tiempoInicio = TimeCurrent();
            secuencias[i].ultimaRecreacionPendiente = 0; // Forzar verificaci√≥n inmediata
            secuencias[i].ultimaVerificacionPendientes = 0; // Inicializar nueva variable
            secuencias[i].sinOrdenesPendientesDetectado = false; // Inicializar nueva variable
            
            // Actualizar proximoIDSecuencia para asegurar que nuevas secuencias tengan IDs √∫nicos
            if(secuencias[i].id >= proximoIDSecuencia)
            {
                proximoIDSecuencia = secuencias[i].id + 1;
                Print("Ajustando ID de pr√≥xima secuencia a: ", proximoIDSecuencia);
            }
            
            totalSecuencias++;
            
            Print("Restaurada secuencia #", secuencias[i].id, " - Modo: ", 
                  secuencias[i].esModoCompra ? "COMPRA" : "VENTA", 
                  ", Entrada2 pendiente: ", secuencias[i].entradaPendienteActiva ? "S√≠" : "No",
                  ", Cerrada manualmente: ", secuencias[i].cerradaManualmente ? "S√≠" : "No");
        }
    }
    
    for(int i = 0; i < 20; i++)
    {
        string baseKey = "EA_SEC_" + Symbol() + "_" + IntegerToString(i) + "_";
        
        if(GlobalVariableCheck(baseKey + "ACTIVA") && GlobalVariableGet(baseKey + "ACTIVA") == 1)
        {
            // Restauraci√≥n existente...
            secuencias[i].tpReubicado = GlobalVariableCheck(baseKey + "TP_REUBICADO") ? 
                                       (GlobalVariableGet(baseKey + "TP_REUBICADO") == 1) : false;
        }
    }
    
}

//+------------------------------------------------------------------+
//| Guardar valores de los controles                                 |
//+------------------------------------------------------------------+
void GuardarValores()
{
    if(ObjectFind(0, EA_OBJ_PREFIX + editLotajeID) >= 0)
        LotajeInicial = StringToDouble(ObjectGetString(0, EA_OBJ_PREFIX + editLotajeID, OBJPROP_TEXT));
        
    if(ObjectFind(0, EA_OBJ_PREFIX + editTP1ID) >= 0)
        TP1Puntos = (int)StringToInteger(ObjectGetString(0, EA_OBJ_PREFIX + editTP1ID, OBJPROP_TEXT));
        
    if(ObjectFind(0, EA_OBJ_PREFIX + editPipsEntrada2ID) >= 0)
        PipsEntrada2 = (int)StringToInteger(ObjectGetString(0, EA_OBJ_PREFIX + editPipsEntrada2ID, OBJPROP_TEXT));
        
    if(ObjectFind(0, EA_OBJ_PREFIX + editTP2ID) >= 0)
        TP2Puntos = (int)StringToInteger(ObjectGetString(0, EA_OBJ_PREFIX + editTP2ID, OBJPROP_TEXT));
        
    if(ObjectFind(0, EA_OBJ_PREFIX + editNumEntradaID) >= 0)
    {
        string texto = ObjectGetString(0, EA_OBJ_PREFIX + editNumEntradaID, OBJPROP_TEXT);
        if(texto == "" || texto == "0")
            NumEntrada = 0;
        else
            NumEntrada = (int)StringToInteger(texto);
    }
        
    if(ObjectFind(0, EA_OBJ_PREFIX + editMinimaGID) >= 0)
        MinimaG = StringToDouble(ObjectGetString(0, EA_OBJ_PREFIX + editMinimaGID, OBJPROP_TEXT));
        
    if(ObjectFind(0, EA_OBJ_PREFIX + editNumCerrarID) >= 0)
    {
        string texto = ObjectGetString(0, EA_OBJ_PREFIX + editNumCerrarID, OBJPROP_TEXT);
        if(texto == "" || texto == "0")
            NumCerrar = 0;
        else
            NumCerrar = (int)StringToInteger(texto);
    }
        
    // Guardar estos valores en variables globales para persistencia entre timeframes
    GlobalVariableSet("EA_LOTAJE_" + Symbol(), LotajeInicial);
    GlobalVariableSet("EA_TP1_" + Symbol(), TP1Puntos);
    GlobalVariableSet("EA_PIPS_E2_" + Symbol(), PipsEntrada2);
    GlobalVariableSet("EA_TP2_" + Symbol(), TP2Puntos);
    GlobalVariableSet("EA_NUM_ENTRADA_" + Symbol(), NumEntrada);
    GlobalVariableSet("EA_MINIMA_G_" + Symbol(), MinimaG);
    GlobalVariableSet("EA_NUM_CERRAR_" + Symbol(), NumCerrar);
}

//+------------------------------------------------------------------+
//| Restaurar valores guardados                                      |
//+------------------------------------------------------------------+
void RestaurarValores()
{
    // Solo restaurar valores si los controles no tienen valores ya
    if(ObjectFind(0, EA_OBJ_PREFIX + editLotajeID) >= 0)
    {
        string textoActual = ObjectGetString(0, EA_OBJ_PREFIX + editLotajeID, OBJPROP_TEXT);
        if(textoActual == "" || textoActual == "0" || textoActual == "0.00")
        {
            // Intentar recuperar desde variables globales solo si el campo est√° vac√≠o
            if(GlobalVariableCheck("EA_LOTAJE_" + Symbol()))
                LotajeInicial = GlobalVariableGet("EA_LOTAJE_" + Symbol());
                
            ObjectSetString(0, EA_OBJ_PREFIX + editLotajeID, OBJPROP_TEXT, DoubleToString(LotajeInicial, 2));
        }
        else
        {
            // Si hay texto ya en el campo, usarlo para actualizar la variable
            LotajeInicial = StringToDouble(textoActual);
        }
    }
    
    if(ObjectFind(0, EA_OBJ_PREFIX + editTP1ID) >= 0)
    {
        string textoActual = ObjectGetString(0, EA_OBJ_PREFIX + editTP1ID, OBJPROP_TEXT);
        if(textoActual == "" || textoActual == "0")
        {
            if(GlobalVariableCheck("EA_TP1_" + Symbol()))
                TP1Puntos = (int)GlobalVariableGet("EA_TP1_" + Symbol());
                
            ObjectSetString(0, EA_OBJ_PREFIX + editTP1ID, OBJPROP_TEXT, IntegerToString(TP1Puntos));
        }
        else
        {
            TP1Puntos = (int)StringToInteger(textoActual);
        }
    }
    
    if(ObjectFind(0, EA_OBJ_PREFIX + editPipsEntrada2ID) >= 0)
    {
        string textoActual = ObjectGetString(0, EA_OBJ_PREFIX + editPipsEntrada2ID, OBJPROP_TEXT);
        if(textoActual == "" || textoActual == "0")
        {
            if(GlobalVariableCheck("EA_PIPS_E2_" + Symbol()))
                PipsEntrada2 = (int)GlobalVariableGet("EA_PIPS_E2_" + Symbol());
                
            ObjectSetString(0, EA_OBJ_PREFIX + editPipsEntrada2ID, OBJPROP_TEXT, IntegerToString(PipsEntrada2));
        }
        else
        {
            PipsEntrada2 = (int)StringToInteger(textoActual);
        }
    }
    
    if(ObjectFind(0, EA_OBJ_PREFIX + editTP2ID) >= 0)
    {
        string textoActual = ObjectGetString(0, EA_OBJ_PREFIX + editTP2ID, OBJPROP_TEXT);
        if(textoActual == "" || textoActual == "0")
        {
            if(GlobalVariableCheck("EA_TP2_" + Symbol()))
                TP2Puntos = (int)GlobalVariableGet("EA_TP2_" + Symbol());
                
            ObjectSetString(0, EA_OBJ_PREFIX + editTP2ID, OBJPROP_TEXT, IntegerToString(TP2Puntos));
        }
        else
        {
            TP2Puntos = (int)StringToInteger(textoActual);
        }
    }
    
    if(ObjectFind(0, EA_OBJ_PREFIX + editNumEntradaID) >= 0)
    {
        string textoActual = ObjectGetString(0, EA_OBJ_PREFIX + editNumEntradaID, OBJPROP_TEXT);
        if(textoActual == "")
        {
            if(GlobalVariableCheck("EA_NUM_ENTRADA_" + Symbol()))
            {
                NumEntrada = (int)GlobalVariableGet("EA_NUM_ENTRADA_" + Symbol());
                // Si es 0, mostrar campo vac√≠o
                if(NumEntrada == 0)
                    ObjectSetString(0, EA_OBJ_PREFIX + editNumEntradaID, OBJPROP_TEXT, "");
                else
                    ObjectSetString(0, EA_OBJ_PREFIX + editNumEntradaID, OBJPROP_TEXT, IntegerToString(NumEntrada));
            }
            else
            {
                // Si no hay valor guardado, dejar vac√≠o
                ObjectSetString(0, EA_OBJ_PREFIX + editNumEntradaID, OBJPROP_TEXT, "");
            }
        }
        else
        {
            NumEntrada = (int)StringToInteger(textoActual);
        }
    }
    
    // Restaurar valor para Minima G.
    if(ObjectFind(0, EA_OBJ_PREFIX + editMinimaGID) >= 0)
    {
        string textoActual = ObjectGetString(0, EA_OBJ_PREFIX + editMinimaGID, OBJPROP_TEXT);
        if(textoActual == "" || textoActual == "0" || textoActual == "0.00")
        {
            if(GlobalVariableCheck("EA_MINIMA_G_" + Symbol()))
                MinimaG = GlobalVariableGet("EA_MINIMA_G_" + Symbol());
                
            ObjectSetString(0, EA_OBJ_PREFIX + editMinimaGID, OBJPROP_TEXT, DoubleToString(MinimaG, 2));
        }
        else
        {
            MinimaG = StringToDouble(textoActual);
        }
    }
    
    // Restaurar valor para # Cerrar (NUEVO)
    if(ObjectFind(0, EA_OBJ_PREFIX + editNumCerrarID) >= 0)
    {
        string textoActual = ObjectGetString(0, EA_OBJ_PREFIX + editNumCerrarID, OBJPROP_TEXT);
        if(textoActual == "")
        {
            if(GlobalVariableCheck("EA_NUM_CERRAR_" + Symbol()))
            {
                NumCerrar = (int)GlobalVariableGet("EA_NUM_CERRAR_" + Symbol());
                // Si es 0, mostrar campo vac√≠o
                if(NumCerrar == 0)
                    ObjectSetString(0, EA_OBJ_PREFIX + editNumCerrarID, OBJPROP_TEXT, "");
                else
                    ObjectSetString(0, EA_OBJ_PREFIX + editNumCerrarID, OBJPROP_TEXT, IntegerToString(NumCerrar));
            }
            else
            {
                // Si no hay valor guardado, dejar vac√≠o
                ObjectSetString(0, EA_OBJ_PREFIX + editNumCerrarID, OBJPROP_TEXT, "");
            }
        }
        else
        {
            NumCerrar = (int)StringToInteger(textoActual);
        }
    }
}

//+------------------------------------------------------------------+
//| Resetear una secuencia                                           |
//+------------------------------------------------------------------+
void ResetearSecuencia(int indice)
{
    secuencias[indice].activa = false;
    secuencias[indice].numOrdenes = 0;
    secuencias[indice].tpAlcanzado = false;
    secuencias[indice].ultimaVerificacionTP = 0;
    secuencias[indice].cerradaCompletamente = false;
    secuencias[indice].intentosCierre = 0;
    secuencias[indice].ultimoCierreIntentado = 0;
    secuencias[indice].esModoCompra = true;
    secuencias[indice].ticketEntrada1 = 0;
    secuencias[indice].ticketEntrada2 = 0;
    secuencias[indice].entradaPendienteActiva = false;
    secuencias[indice].ultimaRecreacionPendiente = 0;
    secuencias[indice].cerradaManualmente = false;
    secuencias[indice].ultimaVerificacionPendientes = 0; // Nueva variable
    secuencias[indice].sinOrdenesPendientesDetectado = false; // Nueva variable
    secuencias[indice].tpReubicado = false;
    
    // Limpiar array de √≥rdenes
    for(int i = 0; i < 10; i++)
    {
        secuencias[indice].ultimasOrdenes[i] = 0;
    }
}

//+------------------------------------------------------------------+
//| Verificar existencia de una orden pendiente                      |
//+------------------------------------------------------------------+
bool VerificarExistenciaOrdenPendiente(ulong ticket)
{
    if(ticket == 0) return false;
    
    for(int i = 0; i < OrdersTotal(); i++)
    {
        ulong ordenTicket = OrderGetTicket(i);
        if(ordenTicket == ticket && OrderSelect(ordenTicket))
        {
            return true;
        }
    }
    
    return false;
}

//+------------------------------------------------------------------+
//| Versi√≥n mejorada de recrear orden entrada #2 para evitar duplicados|
//+------------------------------------------------------------------+
bool RecrearOrdenEntrada2(int indice)
{
    if(!secuencias[indice].activa || secuencias[indice].tpAlcanzado) 
        return false;
    
    // Si la orden fue cerrada manualmente, no la recreamos
    if(secuencias[indice].cerradaManualmente)
    {
        Print("üö´ No se recrea orden pendiente ENTRADA #2 para secuencia #", secuencias[indice].id, " porque fue cerrada manualmente");
        return false;
    }
    
    // Verificar si ya existen √≥rdenes pendientes para esta secuencia y eliminar duplicados
    bool tieneMultiples = false;
    bool tieneOrdenPendiente = TieneOrdenesPendientes(indice, tieneMultiples);
    
    // Si hay m√∫ltiples √≥rdenes pendientes, limpiar las duplicadas
    if(tieneMultiples)
    {
        Print("‚ö†Ô∏è Detectadas √≥rdenes pendientes duplicadas para secuencia #", secuencias[indice].id, " - Limpiando");
        EliminarOrdenesPendientesDuplicadas(indice);
    }

    // Verificar si la orden pendiente de Entrada #2 espec√≠fica existe
    if(VerificarExistenciaOrdenPendiente(secuencias[indice].ticketEntrada2))
    {
        secuencias[indice].entradaPendienteActiva = true;
        return true; // La orden ya existe, no necesita recreaci√≥n
    }
    
    // Si ya hay alguna orden pendiente de esta secuencia pero no es la ENT2 espec√≠fica,
    // vamos a verificar si hay otra orden ENT2 con otro ticket
    if(tieneOrdenPendiente)
    {
        string secPrefix = "SEC" + IntegerToString(secuencias[indice].id) + "_ENT2";
        
        for(int i = 0; i < OrdersTotal(); i++)
        {
            ulong ticket = OrderGetTicket(i);
            if(!OrderSelect(ticket)) continue;
            
            string comentario = OrderGetString(ORDER_COMMENT);
            if(StringFind(comentario, secPrefix) == 0)
            {
                // Encontramos una orden ENT2 diferente a la que ten√≠amos registrada
                secuencias[indice].ticketEntrada2 = ticket;
                secuencias[indice].entradaPendienteActiva = true;
                Print("üìù Actualizado ticket de entrada2 para secuencia #", secuencias[indice].id, " a: ", ticket);
                return true;
            }
        }
    }
    // Evitar recreaciones demasiado frecuentes (m√°ximo una vez cada 5 segundos)
    if(TimeCurrent() - secuencias[indice].ultimaRecreacionPendiente < 5)
        return false;
    
    secuencias[indice].ultimaRecreacionPendiente = TimeCurrent();
    
    // Solo recrear si estamos en la fase inicial (secuenciaActual <= 2)
    // y la entrada pendiente est√° marcada como activa
    if(secuencias[indice].secuenciaActual <= 2 && secuencias[indice].entradaPendienteActiva)
    {
        string comentarioBase = "SEC" + IntegerToString(secuencias[indice].id) + "_";
        string comentarioEnt2 = comentarioBase + "ENT2";
        double lotaje = StringToDouble(ObjectGetString(0, EA_OBJ_PREFIX + editLotajeID, OBJPROP_TEXT)) * 2;
        ulong resultTicket = 0;
        
        Print("üîÑ Recreando orden pendiente ENTRADA #2 para secuencia #", secuencias[indice].id);
        
        if(secuencias[indice].esModoCompra)
        {
            // ENTRADA #2: SELL STOP
            trade.SellStop(lotaje, secuencias[indice].precioEntrada2, _Symbol, 0, secuencias[indice].tp2Precio, ORDER_TIME_GTC, 0, comentarioEnt2);
            resultTicket = trade.ResultOrder();
        }
        else
        {
            // ENTRADA #2: BUY STOP
            trade.BuyStop(lotaje, secuencias[indice].precioEntrada2, _Symbol, 0, secuencias[indice].tp2Precio, ORDER_TIME_GTC, 0, comentarioEnt2);
            resultTicket = trade.ResultOrder();
        }
        
        if(resultTicket > 0)
        {
            secuencias[indice].ticketEntrada2 = resultTicket;
            RegistrarOrden(indice, resultTicket, comentarioEnt2);
            Print("‚úÖ Orden pendiente ENTRADA #2 recreada exitosamente con ticket #", resultTicket);
            return true;
        }
        else
        {
            Print("‚ùå Error al recrear orden pendiente ENTRADA #2: ", GetLastError());
            return false;
        }
    }
    
    return false;
}

//+------------------------------------------------------------------+
//| Funci√≥n para recuperar √≥rdenes pendientes perdidas - mejorada    |
//+------------------------------------------------------------------+
void RecuperarOrdenesPendientes()
{
    // Primero limpiar posibles duplicados en todas las secuencias
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tama√±o del array
    {
        if(secuencias[i].activa)
        {
            bool tieneMultiples = false;
            bool tieneOrdenPendiente = TieneOrdenesPendientes(i, tieneMultiples);
            
            if(tieneMultiples)
            {
                Print("üßπ Limpiando √≥rdenes duplicadas para secuencia #", secuencias[i].id, " durante recuperaci√≥n");
                EliminarOrdenesPendientesDuplicadas(i);
            }
        }
    }
    
    // Ahora recrear √≥rdenes pendientes si es necesario
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tama√±o del array
    {
        if(secuencias[i].activa && secuencias[i].entradaPendienteActiva)
        {
            RecrearOrdenEntrada2(i);
        }
    }
}

//+------------------------------------------------------------------+
//| Funci√≥n modificada para verificar peri√≥dicamente √≥rdenes pendientes |
//+------------------------------------------------------------------+
void VerificarOrdenesPendientes()
{
    // Limitar la frecuencia de verificaci√≥n (cada 5 segundos)
    datetime tiempoActual = TimeCurrent();
    if(tiempoActual - ultimaVerificacionPendientes < 5)
        return;
        
    ultimaVerificacionPendientes = tiempoActual;
    
    // Recorrer todas las secuencias activas
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tama√±o del array
    {
        if(secuencias[i].activa && secuencias[i].entradaPendienteActiva && !secuencias[i].cerradaManualmente)
        {
            // Verificar si hay √≥rdenes pendientes duplicadas
            bool tieneMultiples = false;
            bool tieneOrdenPendiente = TieneOrdenesPendientes(i, tieneMultiples);
            
            // Si hay m√∫ltiples √≥rdenes pendientes, limpiar las duplicadas
            if(tieneMultiples)
            {
                Print("‚ö†Ô∏è Detectadas √≥rdenes pendientes duplicadas para secuencia #", secuencias[i].id, " - Limpiando");
                EliminarOrdenesPendientesDuplicadas(i);
            }
            
            // Verificar si la orden pendiente Entrada #2 sigue existiendo
            if(!VerificarExistenciaOrdenPendiente(secuencias[i].ticketEntrada2) && !tieneOrdenPendiente)
            {
                // Si no existe, intentar recrearla
                Print("üì¢ Orden pendiente ENTRADA #2 no encontrada para secuencia #", secuencias[i].id, " - Intentando recrear");
                RecrearOrdenEntrada2(i);
            }
        }
    }
}

//+------------------------------------------------------------------+
//| Funci√≥n mejorada para verificar si hay secuencias sin √≥rdenes    |
//| pendientes y que tienen posiciones abiertas para cerrarlas       |
//+------------------------------------------------------------------+
void VerificarCierrePorFaltaDePendientes()
{
    datetime tiempoActual = TimeCurrent();
    
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tama√±o del array
    {
        // Solo procesar secuencias activas que no est√°n ya marcadas para cierre
        if(!secuencias[i].activa || secuencias[i].tpAlcanzado) 
            continue;
            
        // Limitar frecuencia de verificaci√≥n para cada secuencia (reducido de 10 a 2 segundos)
        if(tiempoActual - secuencias[i].ultimaVerificacionPendientes < 2)
            continue;
            
        secuencias[i].ultimaVerificacionPendientes = tiempoActual;
        
        // Si ya se detect√≥ que no hay √≥rdenes pendientes, no verificar de nuevo
        if(secuencias[i].sinOrdenesPendientesDetectado)
            continue;
            
        // Verificar si hay posiciones abiertas para esta secuencia
        bool tienePositionesAbiertas = false;
        string secPrefix = "SEC" + IntegerToString(secuencias[i].id) + "_";
        
        for(int p = 0; p < PositionsTotal(); p++)
        {
            ulong ticket = PositionGetTicket(p);
            if(!PositionSelectByTicket(ticket)) continue;
            
            string comentario = PositionGetString(POSITION_COMMENT);
            if(StringFind(comentario, secPrefix) == 0)
            {
                tienePositionesAbiertas = true;
                break;
            }
        }
        
        // Si no tiene posiciones abiertas, no hay nada que hacer
        if(!tienePositionesAbiertas)
            continue;
        
        // Verificar si hay √≥rdenes pendientes para esta secuencia
        bool tieneMultiples = false;
        bool tienePendientes = TieneOrdenesPendientes(i, tieneMultiples);
        
        // Si hay m√∫ltiples √≥rdenes pendientes, limpiar duplicados primero
        if(tieneMultiples)
        {
            Print("‚ö†Ô∏è Detectadas √≥rdenes duplicadas para secuencia #", secuencias[i].id, " durante verificaci√≥n de falta de pendientes");
            EliminarOrdenesPendientesDuplicadas(i);
            tienePendientes = true; // A√∫n queda al menos una despu√©s de la limpieza
        }
        
        // Verificar si hubo una activaci√≥n reciente (tiempo de gracia para evitar cierres prematuros)
        bool activacionReciente = false;
        
        // Verificar historial reciente para detectar activaciones en los √∫ltimos 10 segundos
        datetime startTime = TimeCurrent() - 10; // √öltimos 10 segundos como tiempo de gracia
        if(HistorySelect(startTime, TimeCurrent()))
        {
            for(int h = 0; h < HistoryDealsTotal(); h++)
            {
                ulong dealTicket = HistoryDealGetTicket(h);
                if(!HistoryDealSelect(dealTicket)) continue;
                
                string comentario = HistoryDealGetString(dealTicket, DEAL_COMMENT);
                if(StringFind(comentario, secPrefix) == 0)
                {
                    // Verificar si es una operaci√≥n de entrada (podr√≠a ser una activaci√≥n reciente)
                    if(HistoryDealGetInteger(dealTicket, DEAL_ENTRY) == DEAL_ENTRY_IN)
                    {
                        activacionReciente = true;
                        Print("üïí Activaci√≥n reciente detectada en secuencia #", secuencias[i].id, " - Dando tiempo para programar siguiente orden");
                        break;
                    }
                }
            }
        }
        
        // Si no hay √≥rdenes pendientes, no hay activaci√≥n reciente, y s√≠ hay posiciones abiertas, cerrar la secuencia
        if(!tienePendientes && !activacionReciente && tienePositionesAbiertas)
        {
            // Marcar que se ha detectado la ausencia de √≥rdenes pendientes
            secuencias[i].sinOrdenesPendientesDetectado = true;
            
            Print("‚ö†Ô∏è SECUENCIA #", secuencias[i].id, " SIN √ìRDENES PENDIENTES DETECTADA - Cerrando todas las posiciones");
            
            // Llamar a la funci√≥n de cierre con un flag para cierre r√°pido
            CerrarTodasLasOrdenesDeSecuencia(i, true);
            
            // Si se logr√≥ cerrar todas las posiciones, marcar la secuencia como inactiva
            if(secuencias[i].cerradaCompletamente)
            {
                secuencias[i].activa = false;
                totalSecuencias--;
                Print("‚úÖ Secuencia #", secuencias[i].id, " cerrada correctamente por falta de √≥rdenes pendientes");
            }
            else
            {
                // Si no se cerr√≥ completamente, continuar intentando en los siguientes ticks
                secuencias[i].tpAlcanzado = true; // Usar este flag para forzar cierre en OnTick
                secuencias[i].ultimoCierreIntentado = TimeCurrent();
                Print("‚ö†Ô∏è Cierre parcial de Secuencia #", secuencias[i].id, " - Continuando intentos");
            }
            
            // Guardar el estado actualizado
            GuardarEstadoSecuencias();
        }
    }
}

//+------------------------------------------------------------------+
//| Crear panel principal de la interfaz                             |
//+------------------------------------------------------------------+
void CrearPanelPrincipal(int x, int y, int ancho, int alto)
{
    string fullId = EA_OBJ_PREFIX + panelPrincipalID;
    
    // Crear panel de fondo
    if(ObjectFind(0, fullId) < 0) {
        ObjectCreate(0, fullId, OBJ_RECTANGLE_LABEL, 0, 0, 0);
    }
    
    // Configurar propiedades
    ObjectSetInteger(0, fullId, OBJPROP_XDISTANCE, x);
    ObjectSetInteger(0, fullId, OBJPROP_YDISTANCE, y);
    ObjectSetInteger(0, fullId, OBJPROP_XSIZE, ancho);
    ObjectSetInteger(0, fullId, OBJPROP_YSIZE, alto);
    ObjectSetInteger(0, fullId, OBJPROP_BGCOLOR, clrBlack);
    ObjectSetInteger(0, fullId, OBJPROP_BORDER_TYPE, BORDER_FLAT);
    ObjectSetInteger(0, fullId, OBJPROP_BORDER_COLOR, clrWhite);
    ObjectSetInteger(0, fullId, OBJPROP_CORNER, CORNER_LEFT_UPPER);
    ObjectSetInteger(0, fullId, OBJPROP_WIDTH, 1);
    ObjectSetInteger(0, fullId, OBJPROP_BACK, false);
    ObjectSetInteger(0, fullId, OBJPROP_SELECTABLE, false); // No seleccionable
    ObjectSetInteger(0, fullId, OBJPROP_SELECTED, false);
    ObjectSetInteger(0, fullId, OBJPROP_HIDDEN, true);
    ObjectSetInteger(0, fullId, OBJPROP_ZORDER, 0);
}

//+------------------------------------------------------------------+
//| Crear interfaz gr√°fica                                           |
//+------------------------------------------------------------------+
void CrearInterfaz()
{
    // Comprobar si la interfaz ya existe antes de crearla de nuevo
    if(ObjectFind(0, EA_OBJ_PREFIX + botonCompraID) >= 0 && 
       ObjectFind(0, EA_OBJ_PREFIX + botonVentaID) >= 0) {
        Print("Interfaz ya existe, omitiendo creaci√≥n");
        interfazCreada = true;
        RestaurarValores();
        
        // Nuevo: Restaurar estado de secuencias si existen
        RestaurarEstadoSecuencias();
        return;
    }
    
    // No eliminar todos los objetos, s√≥lo los pertenecientes al EA
    ObjectsDeleteAll(0, EA_OBJ_PREFIX);
    
    // Definir dimensiones del panel y componentes
    int x = 20;
    int y = 20;
    int anchoBotones = 120;
    int altoBoton = 30;
    int anchoPanel = anchoBotones * 2 + 20; // Reducido el espaciado
    int altoPanel = 320; // Aumentado para incluir el nuevo campo # Cerrar
    int espaciado = 10;
    int margenX = 10; // Reducido el margen
    int margenY = 10;
    
    // Crear panel principal
    CrearPanelPrincipal(x, y, anchoPanel, altoPanel);
    
    // Ajustar posiciones para estar dentro del panel
    x += margenX;
    y += margenY;
    
    // Crear controles dentro del panel
    // CAMBIO 1: Botones con posiciones intercambiadas
    CrearBoton(botonVentaID, "VENTA", x, y, anchoBotones, altoBoton, clrRed); // VENTA a la izquierda
    CrearBoton(botonCompraID, "COMPRA", x + anchoBotones + espaciado - 10, y, anchoBotones, altoBoton, clrGreen); // COMPRA a la derecha
    y += altoBoton + espaciado;

    // CAMBIO 2: Campo "Lote inicial" (antes "Lote entrada #1")
    CrearCampoEdicionEstilizado(editLotajeID, "Lote inicial", x, y, anchoBotones * 2, altoBoton, DoubleToString(LotajeInicial, 2));
    y += altoBoton + espaciado;

    // CAMBIO 3 y 4: Campos TP E1 y TP E2 juntos
    CrearCampoEdicionEstilizado(editTP1ID, "TP E1", x, y, anchoBotones * 2, altoBoton, IntegerToString(TP1Puntos));
    y += altoBoton + espaciado;
    
    CrearCampoEdicionEstilizado(editTP2ID, "TP E2", x, y, anchoBotones * 2, altoBoton, IntegerToString(TP2Puntos));
    y += altoBoton + espaciado;
    
    // CAMBIO 5: Campo "Dist. E1/E2" (antes "Entrada #2")
    CrearCampoEdicionEstilizado(editPipsEntrada2ID, "Dist. E1/E2", x, y, anchoBotones * 2, altoBoton, IntegerToString(PipsEntrada2));
    y += altoBoton + espaciado;
    
    // CAMBIO 6: Campo "Ganancia M." (antes "Minima G.")
    CrearCampoEdicionEstilizado(editMinimaGID, "Ganancia M.", x, y, anchoBotones * 2, altoBoton, DoubleToString(MinimaG, 2));
    y += altoBoton + espaciado;
    
    // CAMBIO 7: Campo "# Reubicar" (antes "No. Entrada")
    CrearCampoEdicionEstilizado(editNumEntradaID, "# Reubicar", x, y, anchoBotones * 2, altoBoton, NumEntrada == 0 ? "" : IntegerToString(NumEntrada));
    y += altoBoton + espaciado;
    
    // CAMBIO 8: Nuevo campo "# Cerrar"
    CrearCampoEdicionEstilizado(editNumCerrarID, "# Cerrar", x, y, anchoBotones * 2, altoBoton, NumCerrar == 0 ? "" : IntegerToString(NumCerrar));
    
    // Restaurar valores despu√©s de crear los objetos
    RestaurarValores();
    
    // Nuevo: Restaurar estado de secuencias si existen
    RestaurarEstadoSecuencias();
    
    interfazCreada = true;
    ChartRedraw();
}

//+------------------------------------------------------------------+
//| Crear campos de edici√≥n                                          |
//+------------------------------------------------------------------+
void CrearCampoEdicion(string id, string label, int x, int y, int ancho, int alto, string valor)
{
    string labelId = EA_OBJ_PREFIX + "Label" + id;
    string fullId = EA_OBJ_PREFIX + id;
    
    ObjectCreate(0, labelId, OBJ_LABEL, 0, 0, 0);
    ObjectSetInteger(0, labelId, OBJPROP_XDISTANCE, x);
    ObjectSetInteger(0, labelId, OBJPROP_YDISTANCE, y + 3);
    ObjectSetString(0, labelId, OBJPROP_TEXT, label);
    ObjectSetInteger(0, labelId, OBJPROP_COLOR, clrBlack);

    ObjectCreate(0, fullId, OBJ_EDIT, 0, 0, 0);
    ObjectSetInteger(0, fullId, OBJPROP_XDISTANCE, x + 100);
    ObjectSetInteger(0, fullId, OBJPROP_YDISTANCE, y);
    ObjectSetInteger(0, fullId, OBJPROP_XSIZE, ancho);
    ObjectSetInteger(0, fullId, OBJPROP_YSIZE, alto);
    ObjectSetString(0, fullId, OBJPROP_TEXT, valor);
    ObjectSetInteger(0, fullId, OBJPROP_ALIGN, ALIGN_LEFT);
}
//+------------------------------------------------------------------+
//| Crear campos de edici√≥n estilizados (fondo negro, texto claro)   |
//+------------------------------------------------------------------+
void CrearCampoEdicionEstilizado(string id, string label, int x, int y, int ancho, int alto, string valor)
{
    string labelId = EA_OBJ_PREFIX + "Label" + id;
    string fullId = EA_OBJ_PREFIX + id;
    
    // Crear etiqueta
    ObjectCreate(0, labelId, OBJ_LABEL, 0, 0, 0);
    ObjectSetInteger(0, labelId, OBJPROP_XDISTANCE, x);
    ObjectSetInteger(0, labelId, OBJPROP_YDISTANCE, y + 5);
    ObjectSetString(0, labelId, OBJPROP_TEXT, label);
    ObjectSetInteger(0, labelId, OBJPROP_COLOR, clrWhite);
    ObjectSetInteger(0, labelId, OBJPROP_FONTSIZE, 8);
    ObjectSetInteger(0, labelId, OBJPROP_SELECTABLE, false); // No seleccionable
    
    // Crear campo de edici√≥n
    ObjectCreate(0, fullId, OBJ_EDIT, 0, 0, 0);
    ObjectSetInteger(0, fullId, OBJPROP_XDISTANCE, x + 100);
    ObjectSetInteger(0, fullId, OBJPROP_YDISTANCE, y);
    ObjectSetInteger(0, fullId, OBJPROP_XSIZE, ancho - 100);
    ObjectSetInteger(0, fullId, OBJPROP_YSIZE, alto);
    ObjectSetString(0, fullId, OBJPROP_TEXT, valor);
    ObjectSetInteger(0, fullId, OBJPROP_ALIGN, ALIGN_CENTER);
    ObjectSetInteger(0, fullId, OBJPROP_BGCOLOR, clrBlack);
    ObjectSetInteger(0, fullId, OBJPROP_COLOR, clrWhite);
    ObjectSetInteger(0, fullId, OBJPROP_BORDER_COLOR, clrRed);
    ObjectSetInteger(0, fullId, OBJPROP_SELECTABLE, false); // No seleccionable
    ObjectSetInteger(0, fullId, OBJPROP_READONLY, false);   // Asegurar que se pueda editar
}

//+------------------------------------------------------------------+
//| Crear botones                                                    |
//+------------------------------------------------------------------+
void CrearBoton(string id, string texto, int x, int y, int ancho, int alto, color bgColor)
{
    string fullId = EA_OBJ_PREFIX + id;
    
    ObjectCreate(0, fullId, OBJ_BUTTON, 0, 0, 0);
    ObjectSetInteger(0, fullId, OBJPROP_XDISTANCE, x);
    ObjectSetInteger(0, fullId, OBJPROP_YDISTANCE, y);
    ObjectSetInteger(0, fullId, OBJPROP_XSIZE, ancho);
    ObjectSetInteger(0, fullId, OBJPROP_YSIZE, alto);
    ObjectSetString(0, fullId, OBJPROP_TEXT, texto);
    ObjectSetInteger(0, fullId, OBJPROP_COLOR, clrWhite);
    ObjectSetInteger(0, fullId, OBJPROP_BGCOLOR, bgColor);
    ObjectSetInteger(0, fullId, OBJPROP_BORDER_COLOR, clrBlack);
    ObjectSetInteger(0, fullId, OBJPROP_STATE, false);
}

//+------------------------------------------------------------------+
//| Registrar orden en secuencia                                     |
//+------------------------------------------------------------------+
void RegistrarOrden(int indice, ulong ticket, string comentario="")
{
    if(indice < 0 || indice >= 10 || !secuencias[indice].activa) return;
    
    // Si el array est√° lleno, desplazar hacia abajo
    if(secuencias[indice].numOrdenes >= 10)
    {
        for(int i = 0; i < 9; i++)
        {
            secuencias[indice].ultimasOrdenes[i] = secuencias[indice].ultimasOrdenes[i+1];
        }
        secuencias[indice].ultimasOrdenes[9] = ticket;
    }
    else
    {
        secuencias[indice].ultimasOrdenes[secuencias[indice].numOrdenes] = ticket;
        secuencias[indice].numOrdenes++;
    }
    
    // Guardar los tickets de entrada 1 y 2 espec√≠ficamente
    if(comentario != "")
    {
        if(StringFind(comentario, "ENT1") >= 0 || 
           StringFind(PositionGetString(POSITION_COMMENT), "ENT1") >= 0 ||
           StringFind(OrderGetString(ORDER_COMMENT), "ENT1") >= 0)
        {
            secuencias[indice].ticketEntrada1 = ticket;
            Print("üìù Registrada ENTRADA #1 con ticket #", ticket, " para secuencia #", secuencias[indice].id);
        }
        else if(StringFind(comentario, "ENT2") >= 0 || 
                StringFind(PositionGetString(POSITION_COMMENT), "ENT2") >= 0 ||
                StringFind(OrderGetString(ORDER_COMMENT), "ENT2") >= 0)
        {
            secuencias[indice].ticketEntrada2 = ticket;
            secuencias[indice].entradaPendienteActiva = true; // Marcar que hay una entrada pendiente activa
            Print("üìù Registrada ENTRADA #2 con ticket #", ticket, " para secuencia #", secuencias[indice].id);
        }
    }
    
    Print("Orden #", ticket, " registrada en secuencia #", secuencias[indice].id);
}

//+------------------------------------------------------------------+
//| Iniciar secuencia de compra                                      |
//+------------------------------------------------------------------+
void IniciarSecuenciaCompra()
{
    IniciarSecuencia(true); // true = modo compra
}

//+------------------------------------------------------------------+
//| Iniciar secuencia de venta                                       |
//+------------------------------------------------------------------+
void IniciarSecuenciaVenta()
{
    IniciarSecuencia(false); // false = modo venta
}

//+------------------------------------------------------------------+
//| Cerrar todas las secuencias                                      |
//+------------------------------------------------------------------+
void CerrarTodasLasSecuencias()
{
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tama√±o del array
    {
        if(secuencias[i].activa)
        {
            Print("üö© Iniciando cierre de secuencia #", secuencias[i].id);
            CerrarSecuencia(i);
            Sleep(200); // Pausa entre cierres de secuencias
        }
    }
}

//+------------------------------------------------------------------+
//| Cerrar todas las √≥rdenes de una secuencia                        |
//+------------------------------------------------------------------+
void CerrarTodasLasOrdenesDeSecuencia(int indice, bool cierreRapido = false)
{
    if(!secuencias[indice].activa) return;
    
    string secPrefix = "SEC" + IntegerToString(secuencias[indice].id) + "_";
    bool errorEnCierre = false;
    
    // Configurar slippage para cierres r√°pidos
    if(cierreRapido) {
        // Guardar la desviaci√≥n actual
        int slippage_original = 10; // Valor predeterminado
        
        // Aumentar el slippage para cierre r√°pido
        trade.SetDeviationInPoints(50);
        Print("‚ö° Modo cierre r√°pido activado para secuencia #", secuencias[indice].id, " - Slippage aumentado");
    }
    
    // 1. Guardar todos los tickets de √≥rdenes primero para intentar cerrarlos despu√©s
    int numPosiciones = 0;
    ulong posicionesTickets[50];  // Array para guardar tickets de posiciones
    int numOrdenes = 0;
    ulong ordenesTickets[50];     // Array para guardar tickets de √≥rdenes pendientes
    
    // Obtener todos los tickets de posiciones abiertas de esta secuencia
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        if(StringFind(comentario, secPrefix) == 0)
        {
            posicionesTickets[numPosiciones++] = ticket;
        }
    }
    
    // Obtener todos los tickets de √≥rdenes pendientes de esta secuencia
    for(int i = 0; i < OrdersTotal(); i++)
    {
        ulong ticket = OrderGetTicket(i);
        if(!OrderSelect(ticket)) continue;
        
        string comentario = OrderGetString(ORDER_COMMENT);
        if(StringFind(comentario, secPrefix) == 0)
        {
            ordenesTickets[numOrdenes++] = ticket;
        }
    }
    
    // A√±adir las √≥rdenes espec√≠ficas de entrada 1 y 2 si est√°n registradas
    if(secuencias[indice].ticketEntrada1 > 0)
    {
        bool encontrado = false;
        for(int i = 0; i < numOrdenes; i++)
        {
            if(ordenesTickets[i] == secuencias[indice].ticketEntrada1)
            {
                encontrado = true;
                break;
            }
        }
        if(!encontrado)
        {
            ordenesTickets[numOrdenes++] = secuencias[indice].ticketEntrada1;
            Print("üëÅÔ∏è A√±adida ENTRADA #1 espec√≠fica ticket #", secuencias[indice].ticketEntrada1, " a la lista para cierre");
        }
    }
    
    if(secuencias[indice].ticketEntrada2 > 0)
    {
        bool encontrado = false;
        for(int i = 0; i < numOrdenes; i++)
        {
            if(ordenesTickets[i] == secuencias[indice].ticketEntrada2)
            {
                encontrado = true;
                break;
            }
        }
        if(!encontrado)
        {
            ordenesTickets[numOrdenes++] = secuencias[indice].ticketEntrada2;
            Print("üëÅÔ∏è A√±adida ENTRADA #2 espec√≠fica ticket #", secuencias[indice].ticketEntrada2, " a la lista para cierre");
        }
    }
    // 2. Eliminar todas las √≥rdenes pendientes primero (para evitar que se activen durante el cierre)
    for(int i = 0; i < numOrdenes; i++)
    {
        ulong ticket = ordenesTickets[i];
        if(!OrderSelect(ticket)) continue;
        
        Print("üîµ Eliminando orden pendiente #", ticket, " de secuencia #", secuencias[indice].id);
        if(!trade.OrderDelete(ticket))
        {
            Print("‚ùå Error al eliminar orden #", ticket, ": ", GetLastError());
            errorEnCierre = true;
        }
        else
        {
            Print("‚úÖ Orden #", ticket, " eliminada exitosamente");
        }
        
        // Pausa m√°s corta en modo r√°pido
        if(cierreRapido)
            Sleep(10); // Pausa muy breve
        else
            Sleep(50); // Pausa est√°ndar
    }
    
    // 3. Cerrar todas las posiciones abiertas
    for(int i = 0; i < numPosiciones; i++)
    {
        ulong ticket = posicionesTickets[i];
        if(!PositionSelectByTicket(ticket)) continue;
        
        Print("üî¥ Cerrando posici√≥n #", ticket, " de secuencia #", secuencias[indice].id);
        if(!trade.PositionClose(ticket))
        {
            Print("‚ùå Error al cerrar posici√≥n #", ticket, ": ", GetLastError());
            errorEnCierre = true;
        }
        else
        {
            Print("‚úÖ Posici√≥n #", ticket, " cerrada exitosamente");
        }
        
        // Pausa m√°s corta en modo r√°pido
        if(cierreRapido)
            Sleep(10); // Pausa muy breve
        else
            Sleep(50); // Pausa est√°ndar
    }
    
    // Si hubo errores, un segundo intento m√°s agresivo
    if(errorEnCierre)
    {
        // Pausa m√°s corta en modo r√°pido
        if(cierreRapido)
            Sleep(50); // Pausa breve
        else
            Sleep(200); // Pausa est√°ndar
        
        // Segundo intento para √≥rdenes pendientes
        for(int i = 0; i < OrdersTotal(); i++)
        {
            ulong ticket = OrderGetTicket(i);
            if(!OrderSelect(ticket)) continue;
            
            string comentario = OrderGetString(ORDER_COMMENT);
            if(StringFind(comentario, secPrefix) == 0)
            {
                trade.OrderDelete(ticket);
                if(cierreRapido)
                    Sleep(5);
                else
                    Sleep(50);
            }
        }
        
        // Segundo intento de cierre de posiciones
        for(int i = 0; i < PositionsTotal(); i++)
        {
            ulong ticket = PositionGetTicket(i);
            if(!PositionSelectByTicket(ticket)) continue;
            
            string comentario = PositionGetString(POSITION_COMMENT);
            if(StringFind(comentario, secPrefix) == 0)
            {
                trade.PositionClose(ticket);
                if(cierreRapido)
                    Sleep(5);
                else
                    Sleep(50);
            }
        }
    }
    
    // Verificaci√≥n final
    bool quedanOrdenes = false;
    
    // Verificar si quedan √≥rdenes pendientes
    for(int i = 0; i < OrdersTotal(); i++)
    {
        ulong ticket = OrderGetTicket(i);
        if(OrderSelect(ticket))
        {
            string comentario = OrderGetString(ORDER_COMMENT);
            if(StringFind(comentario, secPrefix) == 0)
            {
                quedanOrdenes = true;
                trade.OrderDelete(ticket); // √öltimo intento
            }
        }
    }
    
    // Verificar si quedan posiciones abiertas
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket))
        {
            string comentario = PositionGetString(POSITION_COMMENT);
            if(StringFind(comentario, secPrefix) == 0)
            {
                quedanOrdenes = true;
                trade.PositionClose(ticket); // √öltimo intento
            }
        }
    }
    
    // Restaurar slippage original si se modific√≥
    if(cierreRapido) {
        trade.SetDeviationInPoints(10); // Restaurar al valor predeterminado
    }
    
    if(!quedanOrdenes)
    {
        secuencias[indice].cerradaCompletamente = true;
        Print("‚úÖ Secuencia #", secuencias[indice].id, " cerrada completamente");
    }
    else if(cierreRapido)
    {
        // En modo r√°pido, intentar un cierre agresivo con retardos m√≠nimos
        Print("‚ö° Realizando √∫ltimo intento de cierre agresivo para secuencia #", secuencias[indice].id);
        
        // Cerrar todas las posiciones restantes con m√°xima prioridad
        for(int i = 0; i < PositionsTotal(); i++)
        {
            ulong ticket = PositionGetTicket(i);
            if(PositionSelectByTicket(ticket))
            {
                string comentario = PositionGetString(POSITION_COMMENT);
                if(StringFind(comentario, secPrefix) == 0)
                {
                    trade.SetDeviationInPoints(100); // M√°ximo slippage para forzar cierre
                    trade.PositionClose(ticket);
                    trade.SetDeviationInPoints(10); // Restaurar al valor predeterminado
                }
            }
        }
        
        // Verificar una √∫ltima vez
        quedanOrdenes = false;
        for(int i = 0; i < PositionsTotal(); i++)
        {
            ulong ticket = PositionGetTicket(i);
            if(PositionSelectByTicket(ticket))
            {
                string comentario = PositionGetString(POSITION_COMMENT);
                if(StringFind(comentario, secPrefix) == 0)
                {
                    quedanOrdenes = true;
                    break;
                }
            }
        }
        
        if(!quedanOrdenes)
        {
            secuencias[indice].cerradaCompletamente = true;
            Print("‚úÖ Secuencia #", secuencias[indice].id, " cerrada completamente despu√©s de intento agresivo");
        }
    }
}
//+------------------------------------------------------------------+
//| Cerrar una secuencia                                             |
//+------------------------------------------------------------------+
void CerrarSecuencia(int indice)
{
    if(!secuencias[indice].activa) return;
    
    string tipoSecuencia = secuencias[indice].esModoCompra ? "COMPRA" : "VENTA";
    Print("üö© Cerrando secuencia #", secuencias[indice].id, " (", tipoSecuencia, ")");
    
    // Usar cierre r√°pido para acelerar el proceso
    CerrarTodasLasOrdenesDeSecuencia(indice, true);
    
    // Si se logr√≥ cerrar completamente
    if(secuencias[indice].cerradaCompletamente)
    {
        secuencias[indice].activa = false;
        secuencias[indice].entradaPendienteActiva = false;
        totalSecuencias--;
        Print("üèÅ Secuencia #", secuencias[indice].id, " (", tipoSecuencia, ") finalizada y marcada como inactiva");
    }
    else
    {
        // Si no se cerr√≥ completamente, mantener activa pero marcar TP
        secuencias[indice].tpAlcanzado = true;
        secuencias[indice].intentosCierre++;
        secuencias[indice].ultimoCierreIntentado = TimeCurrent();
        Print("‚ö†Ô∏è Secuencia #", secuencias[indice].id, " pendiente de cierre completo - Intentos: ", secuencias[indice].intentosCierre);
    }
}

//+------------------------------------------------------------------+
//| Verificar nuevas activaciones                                     |
//+------------------------------------------------------------------+
void VerificarNuevasActivaciones(int indice)
{
    if(!secuencias[indice].activa || secuencias[indice].tpAlcanzado) return;
    
    string comentarioBase = "SEC" + IntegerToString(secuencias[indice].id) + "_ENT" + IntegerToString(secuencias[indice].secuenciaActual);
    bool ordenActivada = false;
    
    // Verificar posiciones abiertas
    for(int i = 0; i < PositionsTotal(); i++)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        
        string comentario = PositionGetString(POSITION_COMMENT);
        if(StringFind(comentario, comentarioBase) >= 0)
        {
            ordenActivada = true;
            break;
        }
    }
    
    // Verificar historial reciente si no se encontr√≥ en posiciones activas
    if(!ordenActivada)
    {
        datetime startTime = TimeCurrent() - 300; // 5 minutos
        if(HistorySelect(startTime, TimeCurrent()))
        {
            for(int i = 0; i < HistoryDealsTotal(); i++)
            {
                ulong dealTicket = HistoryDealGetTicket(i);
                if(!HistoryDealSelect(dealTicket)) continue;
                
                string comentario = HistoryDealGetString(dealTicket, DEAL_COMMENT);
                if(StringFind(comentario, comentarioBase) >= 0)
                {
                    // Si es una operaci√≥n de apertura
                    if(HistoryDealGetInteger(dealTicket, DEAL_ENTRY) == DEAL_ENTRY_IN)
                    {
                        ordenActivada = true;
                        break;
                    }
                }
            }
        }
    }
    
    // Si se activ√≥ una orden y no hay TP alcanzado, programar siguiente
    if(ordenActivada && !secuencias[indice].tpAlcanzado)
    {
        // Si es ENTRADA #2, marcar como inactiva para evitar recreaciones
        if(secuencias[indice].secuenciaActual == 2)
        {
            secuencias[indice].entradaPendienteActiva = false;
            Print("‚öôÔ∏è ENTRADA #2 activada - Desactivando flag de recreaci√≥n");
        }
        
        ProgramarSiguienteEntrada(indice);
    }
}

//+------------------------------------------------------------------+
//| Versi√≥n mejorada de Programar Siguiente Entrada para garantizar  |
//| precios iguales y solo TP en entradas 1 y 2                      |
//+------------------------------------------------------------------+
void ProgramarSiguienteEntrada(int indice)
{
    if(!secuencias[indice].activa || secuencias[indice].tpAlcanzado) return;

    // Verificar si ya existen √≥rdenes pendientes para esta secuencia y eliminar duplicados
    bool tieneMultiples = false;
    bool tieneOrdenPendiente = TieneOrdenesPendientes(indice, tieneMultiples);
    
    // Si hay m√∫ltiples √≥rdenes pendientes, limpiar las duplicadas
    if(tieneMultiples)
    {
        Print("‚ö†Ô∏è Verificando √≥rdenes duplicadas antes de programar siguiente entrada para secuencia #", secuencias[indice].id);
        EliminarOrdenesPendientesDuplicadas(indice);
    }

    double lotajeBase = StringToDouble(ObjectGetString(0, EA_OBJ_PREFIX + editLotajeID, OBJPROP_TEXT));
    
    secuencias[indice].secuenciaActual++;
    double lotaje = lotajeBase * MathPow(2, secuencias[indice].secuenciaActual - 1);

    // Validar que el lotaje no exceda el m√°ximo permitido
    double maxVolume = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
    if(lotaje > maxVolume)
    {
        Print("Advertencia: Lotaje calculado excede el m√°ximo permitido. Usando m√°ximo volumen permitido.");
        lotaje = maxVolume;
    }

    string comentarioBase = "SEC" + IntegerToString(secuencias[indice].id) + "_ENT" + IntegerToString(secuencias[indice].secuenciaActual);
    ulong resultTicket = 0;
    
    // Verificar si ya existe una orden con este comentario espec√≠fico
    for(int i = 0; i < OrdersTotal(); i++)
    {
        ulong ticket = OrderGetTicket(i);
        if(!OrderSelect(ticket)) continue;
        
        string comentario = OrderGetString(ORDER_COMMENT);
        if(StringFind(comentario, comentarioBase) == 0)
        {
            Print("‚ö†Ô∏è Ya existe una orden con comentario ", comentarioBase, " - No se crear√° una nueva");
            return; // Ya existe, no crear una nueva
        }
    }
    
    bool esImpar = secuencias[indice].secuenciaActual % 2 == 1;
    
    // Intentar colocar la orden SIEMPRE a los mismos precios que las entradas 1 y 2 originales
    // Las entradas posteriores ya no tendr√°n TP para simplificar la gesti√≥n
    if(secuencias[indice].esModoCompra)
    {
        // En modo COMPRA: 
        // - Entradas impares: BUY STOP al precio de ENTRADA #1
        // - Entradas pares: SELL STOP al precio de ENTRADA #2
        if(esImpar)
        {
            // IMPORTANTE: Usamos el precio exacto de ENTRADA #1
            // Sin TP en entradas posteriores a la #1 y #2
            trade.BuyStop(lotaje, secuencias[indice].precioEntrada1, _Symbol, 0, 0, ORDER_TIME_GTC, 0, comentarioBase);
            Print("üìù Programando BUY STOP (", comentarioBase, ") al precio exacto de ENTRADA #1: ", 
                 NormalizeDouble(secuencias[indice].precioEntrada1, _Digits));
        }
        else
        {
            // IMPORTANTE: Usamos el precio exacto de ENTRADA #2
            // Sin TP en entradas posteriores a la #1 y #2
            trade.SellStop(lotaje, secuencias[indice].precioEntrada2, _Symbol, 0, 0, ORDER_TIME_GTC, 0, comentarioBase);
            Print("üìù Programando SELL STOP (", comentarioBase, ") al precio exacto de ENTRADA #2: ", 
                 NormalizeDouble(secuencias[indice].precioEntrada2, _Digits));
        }
    }
    else
    {
        // En modo VENTA: 
        // - Entradas impares: SELL STOP al precio de ENTRADA #1
        // - Entradas pares: BUY STOP al precio de ENTRADA #2
        if(esImpar)
        {
            // IMPORTANTE: Usamos el precio exacto de ENTRADA #1
            // Sin TP en entradas posteriores a la #1 y #2
            trade.SellStop(lotaje, secuencias[indice].precioEntrada1, _Symbol, 0, 0, ORDER_TIME_GTC, 0, comentarioBase);
            Print("üìù Programando SELL STOP (", comentarioBase, ") al precio exacto de ENTRADA #1: ", 
                 NormalizeDouble(secuencias[indice].precioEntrada1, _Digits));
        }
        else
        {
            // IMPORTANTE: Usamos el precio exacto de ENTRADA #2
            // Sin TP en entradas posteriores a la #1 y #2
            trade.BuyStop(lotaje, secuencias[indice].precioEntrada2, _Symbol, 0, 0, ORDER_TIME_GTC, 0, comentarioBase);
            Print("üìù Programando BUY STOP (", comentarioBase, ") al precio exacto de ENTRADA #2: ", 
                 NormalizeDouble(secuencias[indice].precioEntrada2, _Digits));
        }
    }
    
    resultTicket = trade.ResultOrder();
    
    // Verificar si hubo error al programar la siguiente entrada
    if(resultTicket == 0)
    {
        int error = GetLastError();
        Print("Error al programar ", comentarioBase, ": ", error);
        return;
    }
    
    if(resultTicket > 0)
    {
        RegistrarOrden(indice, resultTicket, comentarioBase);
        Print(comentarioBase, " programada con lotaje ", lotaje, " al precio exacto de la entrada original");
        
        // Actualizar el estado de las secuencias
        GuardarEstadoSecuencias();
    }
}

//+------------------------------------------------------------------+
//| Funci√≥n com√∫n para iniciar secuencia (compra o venta)            |
//+------------------------------------------------------------------+
void IniciarSecuencia(bool esCompra)
{
    // Eliminada verificaci√≥n de l√≠mite de secuencias
    
    double lotaje = StringToDouble(ObjectGetString(0, EA_OBJ_PREFIX + editLotajeID, OBJPROP_TEXT));
    if(lotaje <= 0)
    {
        Alert("Lotaje inv√°lido");
        return;
    }

    double minVolume = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
    double maxVolume = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
    double volumeStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
    lotaje = MathRound(lotaje / volumeStep) * volumeStep;
    
    if(lotaje < minVolume || lotaje > maxVolume)
    {
        Alert("Lotaje debe estar entre " + DoubleToString(minVolume, 2) + " y " + DoubleToString(maxVolume, 2));
        return;
    }

    int tp1 = (int)StringToInteger(ObjectGetString(0, EA_OBJ_PREFIX + editTP1ID, OBJPROP_TEXT));
    int pipsEntrada2 = (int)StringToInteger(ObjectGetString(0, EA_OBJ_PREFIX + editPipsEntrada2ID, OBJPROP_TEXT));
    int tp2 = (int)StringToInteger(ObjectGetString(0, EA_OBJ_PREFIX + editTP2ID, OBJPROP_TEXT));

    if(tp1 <= 0 || pipsEntrada2 <= 0 || tp2 <= 0)
    {
        Alert("Valores de TP o PIPS inv√°lidos");
        return;
    }

    // Encontrar un slot libre para la nueva secuencia
    int slotLibre = -1;
    for(int i = 0; i < 20; i++) // Ajustado a 20 para coincidir con el tama√±o del array
    {
        if(!secuencias[i].activa)
        {
            slotLibre = i;
            break;
        }
    }
    
    if(slotLibre == -1)
    {
        Alert("Error interno: No se encontr√≥ slot libre para la secuencia");
        return;
    }
    
    // Configurar la nueva secuencia
    secuencias[slotLibre].id = proximoIDSecuencia++;
    secuencias[slotLibre].activa = true;
    secuencias[slotLibre].secuenciaActual = 2;  // Comenzamos con ENTRADA #1 y #2 programadas
    secuencias[slotLibre].tiempoInicio = TimeCurrent();
    secuencias[slotLibre].numOrdenes = 0;
    secuencias[slotLibre].tpAlcanzado = false;
    secuencias[slotLibre].ultimaVerificacionTP = 0;
    secuencias[slotLibre].cerradaCompletamente = false;
    secuencias[slotLibre].intentosCierre = 0;
    secuencias[slotLibre].ultimoCierreIntentado = 0;
    secuencias[slotLibre].esModoCompra = esCompra;
    secuencias[slotLibre].ticketEntrada1 = 0;
    secuencias[slotLibre].ticketEntrada2 = 0;
    secuencias[slotLibre].entradaPendienteActiva = true;  // Nueva: Inicialmente la entrada pendiente est√° activa
    secuencias[slotLibre].ultimaRecreacionPendiente = 0;
    secuencias[slotLibre].ultimaVerificacionPendientes = 0; // Inicializar nueva variable
    secuencias[slotLibre].sinOrdenesPendientesDetectado = false; // Inicializar nueva variable
    secuencias[slotLibre].tpReubicado = false; // Inicializa TP reubicado
    
    string comentarioBase = "SEC" + IntegerToString(secuencias[slotLibre].id) + "_";
    string comentarioEnt1 = comentarioBase + "ENT1";
    string comentarioEnt2 = comentarioBase + "ENT2";
    ulong resultTicket = 0;
    
    if(esCompra)
    {
        // MODO COMPRA: ENTRADA #1 = BUY
        secuencias[slotLibre].precioEntrada1 = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
        secuencias[slotLibre].tp1Precio = NormalizeDouble(secuencias[slotLibre].precioEntrada1 + (tp1 * _Point), _Digits);
        
        trade.Buy(lotaje, _Symbol, 0, 0, secuencias[slotLibre].tp1Precio, comentarioEnt1);
        resultTicket = trade.ResultOrder();
        
        if(resultTicket == 0)
        {
            Alert("Error al abrir ENTRADA #1 (BUY): ", GetLastError());
            secuencias[slotLibre].activa = false;
            return;
        }
        
        RegistrarOrden(slotLibre, resultTicket, comentarioEnt1);

        // ENTRADA #2: SELL STOP
        secuencias[slotLibre].precioEntrada2 = NormalizeDouble(secuencias[slotLibre].precioEntrada1 - (pipsEntrada2 * _Point), _Digits);
        secuencias[slotLibre].tp2Precio = NormalizeDouble(secuencias[slotLibre].precioEntrada2 - (tp2 * _Point), _Digits);
        
        // IMPORTANTE: Sin tiempo de expiraci√≥n (GTC - Good Till Cancelled)
        trade.SellStop(lotaje * 2, secuencias[slotLibre].precioEntrada2, _Symbol, 0, secuencias[slotLibre].tp2Precio, ORDER_TIME_GTC, 0, comentarioEnt2);
        resultTicket = trade.ResultOrder();
    }
    else
    {
        // MODO VENTA: ENTRADA #1 = SELL
        secuencias[slotLibre].precioEntrada1 = SymbolInfoDouble(_Symbol, SYMBOL_BID);
        secuencias[slotLibre].tp1Precio = NormalizeDouble(secuencias[slotLibre].precioEntrada1 - (tp1 * _Point), _Digits);
        
        trade.Sell(lotaje, _Symbol, 0, 0, secuencias[slotLibre].tp1Precio, comentarioEnt1);
        resultTicket = trade.ResultOrder();
        
        if(resultTicket == 0)
        {
            Alert("Error al abrir ENTRADA #1 (SELL): ", GetLastError());
            secuencias[slotLibre].activa = false;
            return;
        }
        
        RegistrarOrden(slotLibre, resultTicket, comentarioEnt1);

        // ENTRADA #2: BUY STOP
        secuencias[slotLibre].precioEntrada2 = NormalizeDouble(secuencias[slotLibre].precioEntrada1 + (pipsEntrada2 * _Point), _Digits);
        secuencias[slotLibre].tp2Precio = NormalizeDouble(secuencias[slotLibre].precioEntrada2 + (tp2 * _Point), _Digits);
        
        // IMPORTANTE: Sin tiempo de expiraci√≥n (GTC - Good Till Cancelled)
        trade.BuyStop(lotaje * 2, secuencias[slotLibre].precioEntrada2, _Symbol, 0, secuencias[slotLibre].tp2Precio, ORDER_TIME_GTC, 0, comentarioEnt2);
        resultTicket = trade.ResultOrder();
    }
    
    if(resultTicket == 0)
    {
        Alert("Error al programar ENTRADA #2: ", GetLastError());
        CerrarSecuencia(slotLibre);
        return;
    }
    
    RegistrarOrden(slotLibre, resultTicket, comentarioEnt2);

    totalSecuencias++;
    string tipoSecuencia = esCompra ? "COMPRA" : "VENTA";
    Print("üîπ Nueva secuencia #", secuencias[slotLibre].id, " iniciada en modo ", tipoSecuencia, 
          " - ENTRADA #1 y #2 programadas [E1:", secuencias[slotLibre].ticketEntrada1, 
          ", E2:", secuencias[slotLibre].ticketEntrada2, "]");
    
    // Guardar el estado inmediatamente para preservarlo en cambios de timeframe
    GuardarEstadoSecuencias();
}